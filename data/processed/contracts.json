{"X": [" pragma solidity ^0.8.22; import {UUPSUpgradeable} from \"../../proxy/utils/UUPSUpgradeable.sol\"; import {ERC1967Utils} from \"../../proxy/ERC1967/ERC1967Utils.sol\"; contract NonUpgradeableMock { uint256 internal _counter; function current() external view returns (uint256) { return _counter; } function increment() external { ++_counter; } } contract UUPSUpgradeableMock is NonUpgradeableMock, UUPSUpgradeable { function _authorizeUpgrade(address) internal override {} } contract UUPSUpgradeableUnsafeMock is UUPSUpgradeableMock { function upgradeToAndCall(address newImplementation, bytes memory data) public payable override { ERC1967Utils.upgradeToAndCall(newImplementation, data); } } contract UUPSUnsupportedProxiableUUIDMock is NonUpgradeableMock { function proxiableUUID() external pure returns (bytes32) { return keccak256(\"invalid UUID\"); } } ", " pragma solidity ^0.8.20; contract BadBeaconNoImpl {} contract BadBeaconNotContract { function implementation() external pure returns (address) { return address(0x1); } } ", " pragma solidity ^0.8.20; import {Initializable} from \"../proxy/utils/Initializable.sol\"; contract Implementation1 is Initializable { uint256 internal _value; function initialize() public initializer {} function setValue(uint256 _number) public { _value = _number; } } contract Implementation2 is Initializable { uint256 internal _value; function initialize() public initializer {} function setValue(uint256 _number) public { _value = _number; } function getValue() public view returns (uint256) { return _value; } } contract Implementation3 is Initializable { uint256 internal _value; function initialize() public initializer {} function setValue(uint256 _number) public { _value = _number; } function getValue(uint256 _number) public view returns (uint256) { return _value + _number; } } contract Implementation4 is Initializable { uint256 internal _value; function initialize() public initializer {} function setValue(uint256 _number) public { _value = _number; } function getValue() public view returns (uint256) { return _value; } fallback() external { _value = 1; } } ", " pragma solidity ^0.8.20; contract CallReceiverMock { event MockFunctionCalled(); event MockFunctionCalledWithArgs(uint256 a, uint256 b); event MockFunctionCalledExtra(address caller, uint256 value); uint256[] private _array; function mockFunction() public payable returns (string memory) { emit MockFunctionCalled(); return \"0x1234\"; } function mockFunctionWritesStorage(bytes32 slot, bytes32 value) public returns (string memory) { assembly (\"memory-safe\") { sstore(slot, value) } return \"0x1234\"; } function mockFunctionEmptyReturn() public payable { emit MockFunctionCalled(); } function mockFunctionEmptyReturnWritesStorage(bytes32 slot, bytes32 value) public payable { assembly (\"memory-safe\") { sstore(slot, value) } emit MockFunctionCalled(); } function mockFunctionWithArgs(uint256 a, uint256 b) public payable returns (string memory) { emit MockFunctionCalledWithArgs(a, b); return \"0x1234\"; } function mockFunctionWithArgsReturn(uint256 a, uint256 b) public payable returns (uint256, uint256) { emit MockFunctionCalledWithArgs(a, b); return (a, b); } function mockFunctionWithArgsReturnWritesStorage( bytes32 slot, bytes32 value, uint256 a, uint256 b ) public payable returns (uint256, uint256) { assembly (\"memory-safe\") { sstore(slot, value) } emit MockFunctionCalledWithArgs(a, b); return (a, b); } function mockFunctionNonPayable() public returns (string memory) { emit MockFunctionCalled(); return \"0x1234\"; } function mockStaticFunction() public pure returns (string memory) { return \"0x1234\"; } function mockStaticFunctionWithArgsReturn(uint256 a, uint256 b) public pure returns (uint256, uint256) { return (a, b); } function mockFunctionRevertsNoReason() public payable { revert(); } function mockFunctionRevertsReason() public payable { revert(\"CallReceiverMock: reverting\"); } function mockFunctionThrows() public payable { assert(false); } function mockFunctionOutOfGas() public payable { for (uint256 i = 0; ; ++i) { _array.push(i); } } function mockFunctionExtra() public payable { emit MockFunctionCalledExtra(msg.sender, msg.value); } } contract CallReceiverMockTrustingForwarder is CallReceiverMock { address private _trustedForwarder; constructor(address trustedForwarder_) { _trustedForwarder = trustedForwarder_; } function isTrustedForwarder(address forwarder) public view virtual returns (bool) { return forwarder == _trustedForwarder; } } ", " pragma solidity ^0.8.24; import {Governor} from \"../../governance/Governor.sol\"; import {GovernorPreventLateQuorum} from \"../../governance/extensions/GovernorPreventLateQuorum.sol\"; import {GovernorSettings} from \"../../governance/extensions/GovernorSettings.sol\"; import {GovernorCountingSimple} from \"../../governance/extensions/GovernorCountingSimple.sol\"; import {GovernorVotes} from \"../../governance/extensions/GovernorVotes.sol\"; abstract contract GovernorPreventLateQuorumMock is GovernorSettings, GovernorVotes, GovernorCountingSimple, GovernorPreventLateQuorum { uint256 private _quorum; constructor(uint256 quorum_) { _quorum = quorum_; } function quorum(uint256) public view override returns (uint256) { return _quorum; } function proposalDeadline( uint256 proposalId ) public view override(Governor, GovernorPreventLateQuorum) returns (uint256) { return super.proposalDeadline(proposalId); } function proposalThreshold() public view override(Governor, GovernorSettings) returns (uint256) { return super.proposalThreshold(); } function _tallyUpdated(uint256 proposalId) internal override(Governor, GovernorPreventLateQuorum) { super._tallyUpdated(proposalId); } } ", " pragma solidity ^0.8.20; import {Initializable} from \"../proxy/utils/Initializable.sol\"; contract InitializableMock is Initializable { bool public initializerRan; bool public onlyInitializingRan; uint256 public x; function isInitializing() public view returns (bool) { return _isInitializing(); } function initialize() public initializer { initializerRan = true; } function initializeOnlyInitializing() public onlyInitializing { onlyInitializingRan = true; } function initializerNested() public initializer { initialize(); } function onlyInitializingNested() public initializer { initializeOnlyInitializing(); } function initializeWithX(uint256 _x) public payable initializer { x = _x; } function nonInitializable(uint256 _x) public payable { x = _x; } function fail() public pure { require(false, \"InitializableMock forced failure\"); } } contract ConstructorInitializableMock is Initializable { bool public initializerRan; bool public onlyInitializingRan; constructor() initializer { initialize(); initializeOnlyInitializing(); } function initialize() public initializer { initializerRan = true; } function initializeOnlyInitializing() public onlyInitializing { onlyInitializingRan = true; } } contract ChildConstructorInitializableMock is ConstructorInitializableMock { bool public childInitializerRan; constructor() initializer { childInitialize(); } function childInitialize() public initializer { childInitializerRan = true; } } contract ReinitializerMock is Initializable { uint256 public counter; function getInitializedVersion() public view returns (uint64) { return _getInitializedVersion(); } function initialize() public initializer { doStuff(); } function reinitialize(uint64 i) public reinitializer(i) { doStuff(); } function nestedReinitialize(uint64 i, uint64 j) public reinitializer(i) { reinitialize(j); } function chainReinitialize(uint64 i, uint64 j) public { reinitialize(i); reinitialize(j); } function disableInitializers() public { _disableInitializers(); } function doStuff() public onlyInitializing { counter++; } } contract DisableNew is Initializable { constructor() { _disableInitializers(); } } contract DisableOld is Initializable { constructor() initializer {} } contract DisableBad1 is DisableNew, DisableOld {} contract DisableBad2 is Initializable { constructor() initializer { _disableInitializers(); } } contract DisableOk is DisableOld, DisableNew {} ", " pragma solidity ^0.8.20; import {AccessControl} from \"../../../access/AccessControl.sol\"; import {ERC20} from \"../../../token/ERC20/ERC20.sol\"; contract AccessControlERC20MintMissing is ERC20, AccessControl { bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\"); bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\"); constructor() ERC20(\"MyToken\", \"TKN\") { _grantRole(DEFAULT_ADMIN_ROLE, msg.sender); } function mint(address to, uint256 amount) public onlyRole(MINTER_ROLE) { _mint(to, amount); } function burn(address from, uint256 amount) public onlyRole(BURNER_ROLE) { _burn(from, amount); } } ", " pragma solidity ^0.8.27; import {IERC7786GatewaySource, IERC7786Recipient} from \"../../interfaces/draft-IERC7786.sol\"; import {InteroperableAddress} from \"../../utils/draft-InteroperableAddress.sol\"; abstract contract ERC7786GatewayMock is IERC7786GatewaySource { using InteroperableAddress for bytes; error InvalidDestination(); error ReceiverError(); uint256 private _lastReceiveId; function supportsAttribute(bytes4 ) public view virtual returns (bool) { return false; } function sendMessage( bytes calldata recipient, bytes calldata payload, bytes[] calldata attributes ) public payable virtual returns (bytes32 sendId) { if (attributes.length > 0) { revert UnsupportedAttribute(bytes4(attributes[0])); } (bool success, uint256 chainid, address target) = recipient.tryParseEvmV1Calldata(); require(success && chainid == block.chainid, InvalidDestination()); bytes4 magic = IERC7786Recipient(target).receiveMessage{value: msg.value}( bytes32(++_lastReceiveId), InteroperableAddress.formatEvmV1(block.chainid, msg.sender), payload ); require(magic == IERC7786Recipient.receiveMessage.selector, ReceiverError()); emit MessageSent( bytes32(0), InteroperableAddress.formatEvmV1(block.chainid, msg.sender), recipient, payload, msg.value, attributes ); return 0; } } ", " pragma solidity ^0.8.20; import {AccessManaged} from \"../access/manager/AccessManaged.sol\"; import {StorageSlot} from \"../utils/StorageSlot.sol\"; abstract contract AccessManagedTarget is AccessManaged { event CalledRestricted(address caller); event CalledUnrestricted(address caller); event CalledFallback(address caller); function fnRestricted() public restricted { emit CalledRestricted(msg.sender); } function fnUnrestricted() public { emit CalledUnrestricted(msg.sender); } function setIsConsumingScheduledOp(bool isConsuming, bytes32 slot) external { bytes32 mask = bytes32(uint256(1 << 160)); if (isConsuming) { StorageSlot.getBytes32Slot(slot).value |= mask; } else { StorageSlot.getBytes32Slot(slot).value &= ~mask; } } fallback() external { emit CalledFallback(msg.sender); } } ", " pragma solidity ^0.8.20; import {ERC4626} from \"../../token/ERC20/extensions/ERC4626.sol\"; abstract contract ERC4626OffsetMock is ERC4626 { uint8 private immutable _offset; constructor(uint8 offset_) { _offset = offset_; } function _decimalsOffset() internal view virtual override returns (uint8) { return _offset; } } ", " pragma solidity ^0.8.24; import {Multicall} from \"../utils/Multicall.sol\"; import {TransientSlot} from \"../utils/TransientSlot.sol\"; contract TransientSlotMock is Multicall { using TransientSlot for *; event AddressValue(bytes32 slot, address value); function tloadAddress(bytes32 slot) public { emit AddressValue(slot, slot.asAddress().tload()); } function tstore(bytes32 slot, address value) public { slot.asAddress().tstore(value); } event BooleanValue(bytes32 slot, bool value); function tloadBoolean(bytes32 slot) public { emit BooleanValue(slot, slot.asBoolean().tload()); } function tstore(bytes32 slot, bool value) public { slot.asBoolean().tstore(value); } event Bytes32Value(bytes32 slot, bytes32 value); function tloadBytes32(bytes32 slot) public { emit Bytes32Value(slot, slot.asBytes32().tload()); } function tstore(bytes32 slot, bytes32 value) public { slot.asBytes32().tstore(value); } event Uint256Value(bytes32 slot, uint256 value); function tloadUint256(bytes32 slot) public { emit Uint256Value(slot, slot.asUint256().tload()); } function tstore(bytes32 slot, uint256 value) public { slot.asUint256().tstore(value); } event Int256Value(bytes32 slot, int256 value); function tloadInt256(bytes32 slot) public { emit Int256Value(slot, slot.asInt256().tload()); } function tstore(bytes32 slot, int256 value) public { slot.asInt256().tstore(value); } } ", " pragma solidity ^0.8.20; contract ERC20ExcessDecimalsMock { function decimals() public pure returns (uint256) { return type(uint256).max; } } ", " pragma solidity ^0.8.21; import {ERC1967Utils} from \"../proxy/ERC1967/ERC1967Utils.sol\"; import {StorageSlot} from \"../utils/StorageSlot.sol\"; abstract contract Impl { function version() public pure virtual returns (string memory); } contract DummyImplementation { uint256 public value; string public text; uint256[] public values; function initializeNonPayable() public { value = 10; } function initializePayable() public payable { value = 100; } function initializeNonPayableWithValue(uint256 _value) public { value = _value; } function initializePayableWithValue(uint256 _value) public payable { value = _value; } function initialize(uint256 _value, string memory _text, uint256[] memory _values) public { value = _value; text = _text; values = _values; } function get() public pure returns (bool) { return true; } function version() public pure virtual returns (string memory) { return \"V1\"; } function reverts() public pure { require(false, \"DummyImplementation reverted\"); } function unsafeOverrideAdmin(address newAdmin) public { StorageSlot.getAddressSlot(ERC1967Utils.ADMIN_SLOT).value = newAdmin; } } contract DummyImplementationV2 is DummyImplementation { function migrate(uint256 newVal) public payable { value = newVal; } function version() public pure override returns (string memory) { return \"V2\"; } } ", " pragma solidity ^0.8.24; import {Governor} from \"../../governance/Governor.sol\"; import {GovernorSettings} from \"../../governance/extensions/GovernorSettings.sol\"; import {GovernorCountingSimple} from \"../../governance/extensions/GovernorCountingSimple.sol\"; import {GovernorVotesQuorumFraction} from \"../../governance/extensions/GovernorVotesQuorumFraction.sol\"; import {GovernorSequentialProposalId} from \"../../governance/extensions/GovernorSequentialProposalId.sol\"; abstract contract GovernorSequentialProposalIdMock is GovernorSettings, GovernorVotesQuorumFraction, GovernorCountingSimple, GovernorSequentialProposalId { function proposalThreshold() public view override(Governor, GovernorSettings) returns (uint256) { return super.proposalThreshold(); } function getProposalId( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) public view virtual override(Governor, GovernorSequentialProposalId) returns (uint256) { return super.getProposalId(targets, values, calldatas, descriptionHash); } function _propose( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, string memory description, address proposer ) internal virtual override(Governor, GovernorSequentialProposalId) returns (uint256 proposalId) { return super._propose(targets, values, calldatas, description, proposer); } } ", " pragma solidity ^0.8.20; import {IERC20} from \"../token/ERC20/IERC20.sol\"; import {IERC3156FlashBorrower} from \"../interfaces/IERC3156.sol\"; import {Address} from \"../utils/Address.sol\"; contract ERC3156FlashBorrowerMock is IERC3156FlashBorrower { bytes32 internal constant _RETURN_VALUE = keccak256(\"ERC3156FlashBorrower.onFlashLoan\"); bool immutable _enableApprove; bool immutable _enableReturn; event BalanceOf(address token, address account, uint256 value); event TotalSupply(address token, uint256 value); constructor(bool enableReturn, bool enableApprove) { _enableApprove = enableApprove; _enableReturn = enableReturn; } function onFlashLoan( address , address token, uint256 amount, uint256 fee, bytes calldata data ) public returns (bytes32) { require(msg.sender == token); emit BalanceOf(token, address(this), IERC20(token).balanceOf(address(this))); emit TotalSupply(token, IERC20(token).totalSupply()); if (data.length > 0) { Address.functionCall(token, data); } if (_enableApprove) { IERC20(token).approve(token, amount + fee); } return _enableReturn ? _RETURN_VALUE : bytes32(0); } } ", " pragma solidity ^0.8.24; import {Votes} from \"../governance/utils/Votes.sol\"; abstract contract VotesMock is Votes { mapping(address voter => uint256) private _votingUnits; function getTotalSupply() public view returns (uint256) { return _getTotalSupply(); } function delegate(address account, address newDelegation) public { return _delegate(account, newDelegation); } function _getVotingUnits(address account) internal view override returns (uint256) { return _votingUnits[account]; } function _mint(address account, uint256 votes) internal { _votingUnits[account] += votes; _transferVotingUnits(address(0), account, votes); } function _burn(address account, uint256 votes) internal { _votingUnits[account] += votes; _transferVotingUnits(account, address(0), votes); } } abstract contract VotesTimestampMock is VotesMock { function clock() public view override returns (uint48) { return uint48(block.timestamp); } function CLOCK_MODE() public view virtual override returns (string memory) { return \"mode=timestamp\"; } } ", " pragma solidity ^0.8.24; import {GovernorCountingSimple} from \"../../governance/extensions/GovernorCountingSimple.sol\"; import {GovernorVotes} from \"../../governance/extensions/GovernorVotes.sol\"; abstract contract GovernorVoteMocks is GovernorVotes, GovernorCountingSimple { function quorum(uint256) public pure override returns (uint256) { return 0; } function votingDelay() public pure override returns (uint256) { return 4; } function votingPeriod() public pure override returns (uint256) { return 16; } } ", " pragma solidity ^0.8.20; import {IERC20, ERC20} from \"../../token/ERC20/ERC20.sol\"; import {ERC4626} from \"../../token/ERC20/extensions/ERC4626.sol\"; contract ERC4626Mock is ERC4626 { constructor(address underlying) ERC20(\"ERC4626Mock\", \"E4626M\") ERC4626(IERC20(underlying)) {} function mint(address account, uint256 amount) external { _mint(account, amount); } function burn(address account, uint256 amount) external { _burn(account, amount); } } ", " pragma solidity ^0.8.24; import {Governor} from \"../../governance/Governor.sol\"; import {GovernorTimelockControl} from \"../../governance/extensions/GovernorTimelockControl.sol\"; import {GovernorSettings} from \"../../governance/extensions/GovernorSettings.sol\"; import {GovernorCountingSimple} from \"../../governance/extensions/GovernorCountingSimple.sol\"; import {GovernorVotesQuorumFraction} from \"../../governance/extensions/GovernorVotesQuorumFraction.sol\"; import {GovernorStorage} from \"../../governance/extensions/GovernorStorage.sol\"; abstract contract GovernorStorageMock is GovernorSettings, GovernorTimelockControl, GovernorVotesQuorumFraction, GovernorCountingSimple, GovernorStorage { function quorum(uint256 blockNumber) public view override(Governor, GovernorVotesQuorumFraction) returns (uint256) { return super.quorum(blockNumber); } function state(uint256 proposalId) public view override(Governor, GovernorTimelockControl) returns (ProposalState) { return super.state(proposalId); } function proposalThreshold() public view override(Governor, GovernorSettings) returns (uint256) { return super.proposalThreshold(); } function proposalNeedsQueuing( uint256 proposalId ) public view virtual override(Governor, GovernorTimelockControl) returns (bool) { return super.proposalNeedsQueuing(proposalId); } function _propose( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, string memory description, address proposer ) internal virtual override(Governor, GovernorStorage) returns (uint256) { return super._propose(targets, values, calldatas, description, proposer); } function _queueOperations( uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) internal override(Governor, GovernorTimelockControl) returns (uint48) { return super._queueOperations(proposalId, targets, values, calldatas, descriptionHash); } function _executeOperations( uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) internal override(Governor, GovernorTimelockControl) { super._executeOperations(proposalId, targets, values, calldatas, descriptionHash); } function _cancel( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) internal override(Governor, GovernorTimelockControl) returns (uint256) { return super._cancel(targets, values, calldatas, descriptionHash); } function _executor() internal view override(Governor, GovernorTimelockControl) returns (address) { return super._executor(); } } ", " pragma solidity ^0.8.20; import {Context} from \"../utils/Context.sol\"; contract ReentrancyAttack is Context { function callSender(bytes calldata data) public { (bool success, ) = _msgSender().call(data); require(success, \"ReentrancyAttack: failed call\"); } function staticcallSender(bytes calldata data) public view { (bool success, ) = _msgSender().staticcall(data); require(success, \"ReentrancyAttack: failed call\"); } } ", " pragma solidity ^0.8.20; contract EtherReceiverMock { bool private _acceptEther; function setAcceptEther(bool acceptEther) public { _acceptEther = acceptEther; } receive() external payable { if (!_acceptEther) { revert(); } } } ", " pragma solidity ^0.8.24; import {Governor} from \"../../governance/Governor.sol\"; import {GovernorTimelockControl} from \"../../governance/extensions/GovernorTimelockControl.sol\"; import {GovernorSettings} from \"../../governance/extensions/GovernorSettings.sol\"; import {GovernorCountingSimple} from \"../../governance/extensions/GovernorCountingSimple.sol\"; import {GovernorVotesQuorumFraction} from \"../../governance/extensions/GovernorVotesQuorumFraction.sol\"; abstract contract GovernorTimelockControlMock is GovernorSettings, GovernorTimelockControl, GovernorVotesQuorumFraction, GovernorCountingSimple { function quorum(uint256 blockNumber) public view override(Governor, GovernorVotesQuorumFraction) returns (uint256) { return super.quorum(blockNumber); } function state(uint256 proposalId) public view override(Governor, GovernorTimelockControl) returns (ProposalState) { return super.state(proposalId); } function proposalThreshold() public view override(Governor, GovernorSettings) returns (uint256) { return super.proposalThreshold(); } function proposalNeedsQueuing( uint256 proposalId ) public view virtual override(Governor, GovernorTimelockControl) returns (bool) { return super.proposalNeedsQueuing(proposalId); } function _queueOperations( uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) internal override(Governor, GovernorTimelockControl) returns (uint48) { return super._queueOperations(proposalId, targets, values, calldatas, descriptionHash); } function _executeOperations( uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) internal override(Governor, GovernorTimelockControl) { super._executeOperations(proposalId, targets, values, calldatas, descriptionHash); } function _cancel( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) internal override(Governor, GovernorTimelockControl) returns (uint256) { return super._cancel(targets, values, calldatas, descriptionHash); } function _executor() internal view override(Governor, GovernorTimelockControl) returns (address) { return super._executor(); } function nonGovernanceFunction() external {} } ", " pragma solidity ^0.8.20; import {ERC20} from \"../../token/ERC20/ERC20.sol\"; abstract contract ERC20ReturnFalseMock is ERC20 { function transfer(address, uint256) public pure override returns (bool) { return false; } function transferFrom(address, address, uint256) public pure override returns (bool) { return false; } function approve(address, uint256) public pure override returns (bool) { return false; } } ", " pragma solidity >=0.6.9; interface ICompoundTimelock { event NewAdmin(address indexed newAdmin); event NewPendingAdmin(address indexed newPendingAdmin); event NewDelay(uint256 indexed newDelay); event CancelTransaction( bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta ); event ExecuteTransaction( bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta ); event QueueTransaction( bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta ); receive() external payable; function GRACE_PERIOD() external view returns (uint256); function MINIMUM_DELAY() external view returns (uint256); function MAXIMUM_DELAY() external view returns (uint256); function admin() external view returns (address); function pendingAdmin() external view returns (address); function delay() external view returns (uint256); function queuedTransactions(bytes32) external view returns (bool); function setDelay(uint256) external; function acceptAdmin() external; function setPendingAdmin(address) external; function queueTransaction( address target, uint256 value, string memory signature, bytes memory data, uint256 eta ) external returns (bytes32); function cancelTransaction( address target, uint256 value, string memory signature, bytes memory data, uint256 eta ) external; function executeTransaction( address target, uint256 value, string memory signature, bytes memory data, uint256 eta ) external payable returns (bytes memory); } ", " pragma solidity ^0.8.20; import {AccessManaged} from \"../../../access/manager/AccessManaged.sol\"; import {ERC20} from \"../../../token/ERC20/ERC20.sol\"; contract AccessManagedERC20Mint is ERC20, AccessManaged { constructor(address manager) ERC20(\"MyToken\", \"TKN\") AccessManaged(manager) {} function mint(address to, uint256 amount) public restricted { _mint(to, amount); } } ", " pragma solidity ^0.8.24; import {VotesExtended} from \"../governance/utils/VotesExtended.sol\"; abstract contract VotesExtendedMock is VotesExtended { mapping(address voter => uint256) private _votingUnits; function getTotalSupply() public view returns (uint256) { return _getTotalSupply(); } function delegate(address account, address newDelegation) public { return _delegate(account, newDelegation); } function _getVotingUnits(address account) internal view override returns (uint256) { return _votingUnits[account]; } function _mint(address account, uint256 votes) internal { _votingUnits[account] += votes; _transferVotingUnits(address(0), account, votes); } function _burn(address account, uint256 votes) internal { _votingUnits[account] += votes; _transferVotingUnits(account, address(0), votes); } } abstract contract VotesExtendedTimestampMock is VotesExtendedMock { function clock() public view override returns (uint48) { return uint48(block.timestamp); } function CLOCK_MODE() public view virtual override returns (string memory) { return \"mode=timestamp\"; } } ", " pragma solidity ^0.8.20; import {MerkleProof} from \"../utils/cryptography/MerkleProof.sol\"; abstract contract MerkleProofCustomHashMock { function customHash(bytes32 a, bytes32 b) internal pure returns (bytes32) { return a < b ? sha256(abi.encode(a, b)) : sha256(abi.encode(b, a)); } function verify(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal view returns (bool) { return MerkleProof.verify(proof, root, leaf, customHash); } function processProof(bytes32[] calldata proof, bytes32 leaf) internal view returns (bytes32) { return MerkleProof.processProof(proof, leaf, customHash); } function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal view returns (bool) { return MerkleProof.verifyCalldata(proof, root, leaf, customHash); } function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal view returns (bytes32) { return MerkleProof.processProofCalldata(proof, leaf, customHash); } function multiProofVerify( bytes32[] calldata proof, bool[] calldata proofFlags, bytes32 root, bytes32[] calldata leaves ) internal view returns (bool) { return MerkleProof.multiProofVerify(proof, proofFlags, root, leaves, customHash); } function processMultiProof( bytes32[] calldata proof, bool[] calldata proofFlags, bytes32[] calldata leaves ) internal view returns (bytes32) { return MerkleProof.processMultiProof(proof, proofFlags, leaves, customHash); } function multiProofVerifyCalldata( bytes32[] calldata proof, bool[] calldata proofFlags, bytes32 root, bytes32[] calldata leaves ) internal view returns (bool) { return MerkleProof.multiProofVerifyCalldata(proof, proofFlags, root, leaves, customHash); } function processMultiProofCalldata( bytes32[] calldata proof, bool[] calldata proofFlags, bytes32[] calldata leaves ) internal view returns (bytes32) { return MerkleProof.processMultiProofCalldata(proof, proofFlags, leaves, customHash); } } ", " pragma solidity ^0.8.20; import {Arrays} from \"../utils/Arrays.sol\"; contract Uint256ArraysMock { using Arrays for uint256[]; uint256[] private _array; constructor(uint256[] memory array) { _array = array; } function findUpperBound(uint256 value) external view returns (uint256) { return _array.findUpperBound(value); } function lowerBound(uint256 value) external view returns (uint256) { return _array.lowerBound(value); } function upperBound(uint256 value) external view returns (uint256) { return _array.upperBound(value); } function lowerBoundMemory(uint256[] memory array, uint256 value) external pure returns (uint256) { return array.lowerBoundMemory(value); } function upperBoundMemory(uint256[] memory array, uint256 value) external pure returns (uint256) { return array.upperBoundMemory(value); } function unsafeAccess(uint256 pos) external view returns (uint256) { return _array.unsafeAccess(pos).value; } function sort(uint256[] memory array) external pure returns (uint256[] memory) { return array.sort(); } function sortReverse(uint256[] memory array) external pure returns (uint256[] memory) { return array.sort(_reverse); } function _reverse(uint256 a, uint256 b) private pure returns (bool) { return a > b; } function unsafeSetLength(uint256 newLength) external { _array.unsafeSetLength(newLength); } function length() external view returns (uint256) { return _array.length; } } contract AddressArraysMock { using Arrays for address[]; address[] private _array; constructor(address[] memory array) { _array = array; } function unsafeAccess(uint256 pos) external view returns (address) { return _array.unsafeAccess(pos).value; } function sort(address[] memory array) external pure returns (address[] memory) { return array.sort(); } function sortReverse(address[] memory array) external pure returns (address[] memory) { return array.sort(_reverse); } function _reverse(address a, address b) private pure returns (bool) { return uint160(a) > uint160(b); } function unsafeSetLength(uint256 newLength) external { _array.unsafeSetLength(newLength); } function length() external view returns (uint256) { return _array.length; } } contract Bytes32ArraysMock { using Arrays for bytes32[]; bytes32[] private _array; constructor(bytes32[] memory array) { _array = array; } function unsafeAccess(uint256 pos) external view returns (bytes32) { return _array.unsafeAccess(pos).value; } function sort(bytes32[] memory array) external pure returns (bytes32[] memory) { return array.sort(); } function sortReverse(bytes32[] memory array) external pure returns (bytes32[] memory) { return array.sort(_reverse); } function _reverse(bytes32 a, bytes32 b) private pure returns (bool) { return uint256(a) > uint256(b); } function unsafeSetLength(uint256 newLength) external { _array.unsafeSetLength(newLength); } function length() external view returns (uint256) { return _array.length; } } contract BytesArraysMock { using Arrays for bytes[]; bytes[] private _array; constructor(bytes[] memory array) { _array = array; } function unsafeAccess(uint256 pos) external view returns (bytes memory) { return _array.unsafeAccess(pos).value; } function unsafeSetLength(uint256 newLength) external { _array.unsafeSetLength(newLength); } function length() external view returns (uint256) { return _array.length; } } contract StringArraysMock { using Arrays for string[]; string[] private _array; constructor(string[] memory array) { _array = array; } function unsafeAccess(uint256 pos) external view returns (string memory) { return _array.unsafeAccess(pos).value; } function unsafeSetLength(uint256 newLength) external { _array.unsafeSetLength(newLength); } function length() external view returns (uint256) { return _array.length; } } ", " pragma solidity ^0.8.24; import {Governor} from \"../../governance/Governor.sol\"; import {GovernorCountingSimple} from \"../../governance/extensions/GovernorCountingSimple.sol\"; import {GovernorVotes} from \"../../governance/extensions/GovernorVotes.sol\"; abstract contract GovernorWithParamsMock is GovernorVotes, GovernorCountingSimple { event CountParams(uint256 uintParam, string strParam); function quorum(uint256) public pure override returns (uint256) { return 0; } function votingDelay() public pure override returns (uint256) { return 4; } function votingPeriod() public pure override returns (uint256) { return 16; } function _getVotes( address account, uint256 blockNumber, bytes memory params ) internal view override(Governor, GovernorVotes) returns (uint256) { uint256 reduction = 0; if (params.length > 0) { (reduction, ) = abi.decode(params, (uint256, string)); } return super._getVotes(account, blockNumber, params) - reduction; } function _countVote( uint256 proposalId, address account, uint8 support, uint256 weight, bytes memory params ) internal override(Governor, GovernorCountingSimple) returns (uint256) { if (params.length > 0) { (uint256 _uintParam, string memory _strParam) = abi.decode(params, (uint256, string)); emit CountParams(_uintParam, _strParam); } return super._countVote(proposalId, account, support, weight, params); } } ", " pragma solidity ^0.8.20; import {IERC1363Receiver} from \"../../interfaces/IERC1363Receiver.sol\"; contract ERC1363ReceiverMock is IERC1363Receiver { enum RevertType { None, RevertWithoutMessage, RevertWithMessage, RevertWithCustomError, Panic } bytes4 private _retval; RevertType private _error; event Received(address operator, address from, uint256 value, bytes data); error CustomError(bytes4); constructor() { _retval = IERC1363Receiver.onTransferReceived.selector; _error = RevertType.None; } function setUp(bytes4 retval, RevertType error) public { _retval = retval; _error = error; } function onTransferReceived( address operator, address from, uint256 value, bytes calldata data ) external override returns (bytes4) { if (_error == RevertType.RevertWithoutMessage) { revert(); } else if (_error == RevertType.RevertWithMessage) { revert(\"ERC1363ReceiverMock: reverting\"); } else if (_error == RevertType.RevertWithCustomError) { revert CustomError(_retval); } else if (_error == RevertType.Panic) { uint256 a = uint256(0) / uint256(0); a; } emit Received(operator, from, value, data); return _retval; } } ", " pragma solidity ^0.8.20; import {ERC20} from \"../../token/ERC20/ERC20.sol\"; abstract contract ERC20ApprovalMock is ERC20 { function _approve(address owner, address spender, uint256 amount, bool) internal virtual override { super._approve(owner, spender, amount, true); } } ", " pragma solidity ^0.8.20; import {ContextMock} from \"./ContextMock.sol\"; import {Context} from \"../utils/Context.sol\"; import {Multicall} from \"../utils/Multicall.sol\"; import {ERC2771Context} from \"../metatx/ERC2771Context.sol\"; contract ERC2771ContextMock is ContextMock, ERC2771Context, Multicall { constructor(address trustedForwarder) ERC2771Context(trustedForwarder) { emit Sender(_msgSender()); } function _msgSender() internal view override(Context, ERC2771Context) returns (address) { return ERC2771Context._msgSender(); } function _msgData() internal view override(Context, ERC2771Context) returns (bytes calldata) { return ERC2771Context._msgData(); } function _contextSuffixLength() internal view override(Context, ERC2771Context) returns (uint256) { return ERC2771Context._contextSuffixLength(); } } ", " pragma solidity ^0.8.24; import {ECDSA} from \"../utils/cryptography/ECDSA.sol\"; import {EIP712} from \"../utils/cryptography/EIP712.sol\"; abstract contract EIP712Verifier is EIP712 { function verify(bytes memory signature, address signer, address mailTo, string memory mailContents) external view { bytes32 digest = _hashTypedDataV4( keccak256(abi.encode(keccak256(\"Mail(address to,string contents)\"), mailTo, keccak256(bytes(mailContents)))) ); address recoveredSigner = ECDSA.recover(digest, signature); require(recoveredSigner == signer); } } ", " pragma solidity ^0.8.24; import {ERC7739} from \"../../../utils/cryptography/signers/draft-ERC7739.sol\"; import {SignerECDSA} from \"../../../utils/cryptography/signers/SignerECDSA.sol\"; import {SignerP256} from \"../../../utils/cryptography/signers/SignerP256.sol\"; import {SignerRSA} from \"../../../utils/cryptography/signers/SignerRSA.sol\"; abstract contract ERC7739ECDSAMock is ERC7739, SignerECDSA {} abstract contract ERC7739P256Mock is ERC7739, SignerP256 {} abstract contract ERC7739RSAMock is ERC7739, SignerRSA {} ", " pragma solidity ^0.5.0; contract OverflowExample { uint8 public balance = 250; function add(uint8 _value) public { balance = balance + _value; } } ", " pragma solidity ^0.8.27; import {ERC7786Recipient} from \"../../crosschain/ERC7786Recipient.sol\"; contract ERC7786RecipientMock is ERC7786Recipient { address private immutable _gateway; event MessageReceived(address gateway, bytes32 receiveId, bytes sender, bytes payload, uint256 value); constructor(address gateway_) { _gateway = gateway_; } function _isAuthorizedGateway( address gateway, bytes calldata ) internal view virtual override returns (bool) { return gateway == _gateway; } function _processMessage( address gateway, bytes32 receiveId, bytes calldata sender, bytes calldata payload ) internal virtual override { emit MessageReceived(gateway, receiveId, sender, payload, msg.value); } } ", " pragma solidity ^0.8.20; import {ERC20} from \"../../token/ERC20/ERC20.sol\"; contract ERC20WithAutoMinerReward is ERC20 { constructor() ERC20(\"Reward\", \"RWD\") { _mintMinerReward(); } function _mintMinerReward() internal { _mint(block.coinbase, 1000); } function _update(address from, address to, uint256 value) internal virtual override { if (!(from == address(0) && to == block.coinbase)) { _mintMinerReward(); } super._update(from, to, value); } } ", " pragma solidity ^0.8.24; import {ERC20Votes} from \"../../token/ERC20/extensions/ERC20Votes.sol\"; import {VotesExtended, Votes} from \"../../governance/utils/VotesExtended.sol\"; import {SafeCast} from \"../../utils/math/SafeCast.sol\"; abstract contract ERC20VotesExtendedMock is ERC20Votes, VotesExtended { function _delegate(address account, address delegatee) internal virtual override(Votes, VotesExtended) { return super._delegate(account, delegatee); } function _transferVotingUnits( address from, address to, uint256 amount ) internal virtual override(Votes, VotesExtended) { return super._transferVotingUnits(from, to, amount); } } abstract contract ERC20VotesExtendedTimestampMock is ERC20VotesExtendedMock { function clock() public view virtual override returns (uint48) { return SafeCast.toUint48(block.timestamp); } function CLOCK_MODE() public view virtual override returns (string memory) { return \"mode=timestamp\"; } } ", " pragma solidity ^0.8.24; import {Governor} from \"../../governance/Governor.sol\"; import {GovernorSettings} from \"../../governance/extensions/GovernorSettings.sol\"; import {GovernorCountingFractional} from \"../../governance/extensions/GovernorCountingFractional.sol\"; import {GovernorVotesQuorumFraction} from \"../../governance/extensions/GovernorVotesQuorumFraction.sol\"; abstract contract GovernorFractionalMock is GovernorSettings, GovernorVotesQuorumFraction, GovernorCountingFractional { function proposalThreshold() public view override(Governor, GovernorSettings) returns (uint256) { return super.proposalThreshold(); } } ", " pragma solidity ^0.8.24; import {Governor} from \"../../governance/Governor.sol\"; import {GovernorSettings} from \"../../governance/extensions/GovernorSettings.sol\"; import {GovernorVotes} from \"../../governance/extensions/GovernorVotes.sol\"; import {GovernorSuperQuorum} from \"../../governance/extensions/GovernorSuperQuorum.sol\"; import {GovernorCountingSimple} from \"../../governance/extensions/GovernorCountingSimple.sol\"; import {GovernorTimelockControl} from \"../../governance/extensions/GovernorTimelockControl.sol\"; abstract contract GovernorSuperQuorumMock is GovernorSettings, GovernorVotes, GovernorTimelockControl, GovernorSuperQuorum, GovernorCountingSimple { uint256 private _quorum; uint256 private _superQuorum; constructor(uint256 quorum_, uint256 superQuorum_) { _quorum = quorum_; _superQuorum = superQuorum_; } function quorum(uint256) public view override returns (uint256) { return _quorum; } function superQuorum(uint256) public view override returns (uint256) { return _superQuorum; } function state( uint256 proposalId ) public view override(Governor, GovernorSuperQuorum, GovernorTimelockControl) returns (ProposalState) { return super.state(proposalId); } function proposalThreshold() public view override(Governor, GovernorSettings) returns (uint256) { return super.proposalThreshold(); } function proposalVotes( uint256 proposalId ) public view virtual override(GovernorCountingSimple, GovernorSuperQuorum) returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes) { return super.proposalVotes(proposalId); } function _cancel( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) internal override(Governor, GovernorTimelockControl) returns (uint256) { return super._cancel(targets, values, calldatas, descriptionHash); } function _executeOperations( uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) internal override(Governor, GovernorTimelockControl) { super._executeOperations(proposalId, targets, values, calldatas, descriptionHash); } function _executor() internal view override(Governor, GovernorTimelockControl) returns (address) { return super._executor(); } function _queueOperations( uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) internal override(Governor, GovernorTimelockControl) returns (uint48) { return super._queueOperations(proposalId, targets, values, calldatas, descriptionHash); } function proposalNeedsQueuing( uint256 proposalId ) public view override(Governor, GovernorTimelockControl) returns (bool) { return super.proposalNeedsQueuing(proposalId); } } ", " pragma solidity ^0.8.20; import {AccessControl} from \"../../../access/AccessControl.sol\"; import {ERC20} from \"../../../token/ERC20/ERC20.sol\"; contract AccessControlERC20Mint is ERC20, AccessControl { bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\"); bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\"); constructor(address minter, address burner) ERC20(\"MyToken\", \"TKN\") { _grantRole(MINTER_ROLE, minter); _grantRole(BURNER_ROLE, burner); } function mint(address to, uint256 amount) public onlyRole(MINTER_ROLE) { _mint(to, amount); } function burn(address from, uint256 amount) public onlyRole(BURNER_ROLE) { _burn(from, amount); } } ", " pragma solidity ^0.8.20; import {ERC20FlashMint} from \"../../token/ERC20/extensions/ERC20FlashMint.sol\"; abstract contract ERC20FlashMintMock is ERC20FlashMint { uint256 _flashFeeAmount; address _flashFeeReceiverAddress; function setFlashFee(uint256 amount) public { _flashFeeAmount = amount; } function _flashFee(address, uint256) internal view override returns (uint256) { return _flashFeeAmount; } function setFlashFeeReceiver(address receiver) public { _flashFeeReceiverAddress = receiver; } function _flashFeeReceiver() internal view override returns (address) { return _flashFeeReceiverAddress; } } ", " pragma solidity ^0.8.20; import {ERC20MulticallMock} from \"./token/ERC20MulticallMock.sol\"; contract MulticallHelper { function checkReturnValues( ERC20MulticallMock multicallToken, address[] calldata recipients, uint256[] calldata amounts ) external { bytes[] memory calls = new bytes[](recipients.length); for (uint256 i = 0; i < recipients.length; i++) { calls[i] = abi.encodeCall(multicallToken.transfer, (recipients[i], amounts[i])); } bytes[] memory results = multicallToken.multicall(calls); for (uint256 i = 0; i < results.length; i++) { require(abi.decode(results[i], (bool))); } } } ", " pragma solidity ^0.8.20; import {IERC165} from \"../utils/introspection/IERC165.sol\"; contract SupportsInterfaceWithLookupMock is IERC165 { bytes4 public constant INTERFACE_ID_ERC165 = 0x01ffc9a7; mapping(bytes4 interfaceId => bool) private _supportedInterfaces; constructor() { _registerInterface(INTERFACE_ID_ERC165); } function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { return _supportedInterfaces[interfaceId]; } function _registerInterface(bytes4 interfaceId) internal { require(interfaceId != 0xffffffff, \"ERC165InterfacesSupported: invalid interface id\"); _supportedInterfaces[interfaceId] = true; } } contract ERC165InterfacesSupported is SupportsInterfaceWithLookupMock { constructor(bytes4[] memory interfaceIds) { for (uint256 i = 0; i < interfaceIds.length; i++) { _registerInterface(interfaceIds[i]); } } } contract ERC165RevertInvalid is SupportsInterfaceWithLookupMock { constructor(bytes4[] memory interfaceIds) { for (uint256 i = 0; i < interfaceIds.length; i++) { _registerInterface(interfaceIds[i]); } } function supportsInterface(bytes4 interfaceId) public view override returns (bool) { require(super.supportsInterface(interfaceId)); return true; } } contract ERC165MaliciousData { function supportsInterface(bytes4) public pure returns (bool) { assembly { mstore(0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) return(0, 32) } } } contract ERC165MissingData { function supportsInterface(bytes4 interfaceId) public view {} } contract ERC165NotSupported {} contract ERC165ReturnBombMock is IERC165 { function supportsInterface(bytes4 interfaceId) public pure override returns (bool) { if (interfaceId == type(IERC165).interfaceId) { assembly { mstore(0, 1) } } assembly { return(0, 101500) } } } ", " pragma solidity ^0.8.24; import {Governor} from \"../../governance/Governor.sol\"; import {GovernorTimelockAccess} from \"../../governance/extensions/GovernorTimelockAccess.sol\"; import {GovernorSettings} from \"../../governance/extensions/GovernorSettings.sol\"; import {GovernorCountingSimple} from \"../../governance/extensions/GovernorCountingSimple.sol\"; import {GovernorVotesQuorumFraction} from \"../../governance/extensions/GovernorVotesQuorumFraction.sol\"; abstract contract GovernorTimelockAccessMock is GovernorSettings, GovernorTimelockAccess, GovernorVotesQuorumFraction, GovernorCountingSimple { function nonGovernanceFunction() external {} function quorum(uint256 blockNumber) public view override(Governor, GovernorVotesQuorumFraction) returns (uint256) { return super.quorum(blockNumber); } function proposalThreshold() public view override(Governor, GovernorSettings) returns (uint256) { return super.proposalThreshold(); } function proposalNeedsQueuing( uint256 proposalId ) public view virtual override(Governor, GovernorTimelockAccess) returns (bool) { return super.proposalNeedsQueuing(proposalId); } function propose( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, string memory description ) public override(Governor, GovernorTimelockAccess) returns (uint256) { return super.propose(targets, values, calldatas, description); } function _queueOperations( uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) internal override(Governor, GovernorTimelockAccess) returns (uint48) { return super._queueOperations(proposalId, targets, values, calldatas, descriptionHash); } function _executeOperations( uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) internal override(Governor, GovernorTimelockAccess) { super._executeOperations(proposalId, targets, values, calldatas, descriptionHash); } function _cancel( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) internal override(Governor, GovernorTimelockAccess) returns (uint256) { return super._cancel(targets, values, calldatas, descriptionHash); } } ", " pragma solidity ^0.8.20; import {Ownable} from \"../access/Ownable.sol\"; import {IERC1271} from \"../interfaces/IERC1271.sol\"; import {ECDSA} from \"../utils/cryptography/ECDSA.sol\"; contract ERC1271WalletMock is Ownable, IERC1271 { constructor(address originalOwner) Ownable(originalOwner) {} function isValidSignature(bytes32 hash, bytes memory signature) public view returns (bytes4 magicValue) { return ECDSA.recover(hash, signature) == owner() ? this.isValidSignature.selector : bytes4(0); } } contract ERC1271MaliciousMock is IERC1271 { function isValidSignature(bytes32, bytes memory) public pure returns (bytes4) { assembly { mstore(0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) return(0, 32) } } } ", " pragma solidity ^0.8.24; import {ERC721} from \"../../token/ERC721/ERC721.sol\"; import {ERC721Consecutive} from \"../../token/ERC721/extensions/ERC721Consecutive.sol\"; import {ERC721Enumerable} from \"../../token/ERC721/extensions/ERC721Enumerable.sol\"; contract ERC721ConsecutiveEnumerableMock is ERC721Consecutive, ERC721Enumerable { constructor( string memory name, string memory symbol, address[] memory receivers, uint96[] memory amounts ) ERC721(name, symbol) { for (uint256 i = 0; i < receivers.length; ++i) { _mintConsecutive(receivers[i], amounts[i]); } } function supportsInterface( bytes4 interfaceId ) public view virtual override(ERC721, ERC721Enumerable) returns (bool) { return super.supportsInterface(interfaceId); } function _ownerOf(uint256 tokenId) internal view virtual override(ERC721, ERC721Consecutive) returns (address) { return super._ownerOf(tokenId); } function _update( address to, uint256 tokenId, address auth ) internal virtual override(ERC721Consecutive, ERC721Enumerable) returns (address) { return super._update(to, tokenId, auth); } function _increaseBalance(address account, uint128 amount) internal virtual override(ERC721, ERC721Enumerable) { super._increaseBalance(account, amount); } } ", " pragma solidity ^0.8.20; import {ERC20} from \"../../token/ERC20/ERC20.sol\"; abstract contract ERC20ForceApproveMock is ERC20 { function approve(address spender, uint256 amount) public virtual override returns (bool) { require(amount == 0 || allowance(msg.sender, spender) == 0, \"USDT approval failure\"); return super.approve(spender, amount); } } ", " pragma solidity ^0.8.20; import {IAccessManaged} from \"../access/manager/IAccessManaged.sol\"; import {IAuthority} from \"../access/manager/IAuthority.sol\"; contract NotAuthorityMock is IAuthority { function canCall(address , address , bytes4 ) external pure returns (bool) { revert(\"NotAuthorityMock: not implemented\"); } } contract AuthorityNoDelayMock is IAuthority { bool private _immediate; function canCall( address , address , bytes4 ) external view returns (bool immediate) { return _immediate; } function _setImmediate(bool immediate) external { _immediate = immediate; } } contract AuthorityDelayMock { bool private _immediate; uint256 private _delay; function canCall( address , address , bytes4 ) external view returns (bool immediate, uint256 delay) { return (_immediate, _delay); } function _setImmediate(bool immediate) external { _immediate = immediate; } function _setDelay(uint256 delay) external { _delay = delay; } } contract AuthorityNoResponse { function canCall(address , address , bytes4 ) external view {} } contract AuthorityObserveIsConsuming { event ConsumeScheduledOpCalled(address caller, bytes data, bytes4 isConsuming); function canCall( address , address , bytes4 ) external pure returns (bool immediate, uint32 delay) { return (false, 1); } function consumeScheduledOp(address caller, bytes memory data) public { emit ConsumeScheduledOpCalled(caller, data, IAccessManaged(msg.sender).isConsumingScheduledOp()); } } ", " pragma solidity ^0.8.24; import {ERC20Votes} from \"../../token/ERC20/extensions/ERC20Votes.sol\"; import {ERC721Votes} from \"../../token/ERC721/extensions/ERC721Votes.sol\"; import {SafeCast} from \"../../utils/math/SafeCast.sol\"; abstract contract ERC20VotesTimestampMock is ERC20Votes { function clock() public view virtual override returns (uint48) { return SafeCast.toUint48(block.timestamp); } function CLOCK_MODE() public view virtual override returns (string memory) { return \"mode=timestamp\"; } } abstract contract ERC721VotesTimestampMock is ERC721Votes { function clock() public view virtual override returns (uint48) { return SafeCast.toUint48(block.timestamp); } function CLOCK_MODE() public view virtual override returns (string memory) { return \"mode=timestamp\"; } } ", " pragma solidity ^0.8.20; contract CompTimelock { event NewAdmin(address indexed newAdmin); event NewPendingAdmin(address indexed newPendingAdmin); event NewDelay(uint256 indexed newDelay); event CancelTransaction( bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta ); event ExecuteTransaction( bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta ); event QueueTransaction( bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta ); uint256 public constant GRACE_PERIOD = 14 days; uint256 public constant MINIMUM_DELAY = 2 days; uint256 public constant MAXIMUM_DELAY = 30 days; address public admin; address public pendingAdmin; uint256 public delay; mapping(bytes32 => bool) public queuedTransactions; constructor(address admin_, uint256 delay_) { require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\"); require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\"); admin = admin_; delay = delay_; } receive() external payable {} function setDelay(uint256 delay_) public { require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\"); require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\"); require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\"); delay = delay_; emit NewDelay(delay); } function acceptAdmin() public { require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\"); admin = msg.sender; pendingAdmin = address(0); emit NewAdmin(admin); } function setPendingAdmin(address pendingAdmin_) public { require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\"); pendingAdmin = pendingAdmin_; emit NewPendingAdmin(pendingAdmin); } function queueTransaction( address target, uint256 value, string memory signature, bytes memory data, uint256 eta ) public returns (bytes32) { require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\"); require( eta >= getBlockTimestamp() + delay, \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\" ); bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta)); queuedTransactions[txHash] = true; emit QueueTransaction(txHash, target, value, signature, data, eta); return txHash; } function cancelTransaction( address target, uint256 value, string memory signature, bytes memory data, uint256 eta ) public { require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\"); bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta)); queuedTransactions[txHash] = false; emit CancelTransaction(txHash, target, value, signature, data, eta); } function executeTransaction( address target, uint256 value, string memory signature, bytes memory data, uint256 eta ) public payable returns (bytes memory) { require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\"); bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta)); require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\"); require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\"); require(getBlockTimestamp() <= eta + GRACE_PERIOD, \"Timelock::executeTransaction: Transaction is stale.\"); queuedTransactions[txHash] = false; bytes memory callData; if (bytes(signature).length == 0) { callData = data; } else { callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data); } (bool success, bytes memory returnData) = target.call{value: value}(callData); require(success, \"Timelock::executeTransaction: Transaction execution reverted.\"); emit ExecuteTransaction(txHash, target, value, signature, data, eta); return returnData; } function getBlockTimestamp() internal view returns (uint256) { return block.timestamp; } } ", " pragma solidity ^0.8.24; import {ERC721URIStorage} from \"../../token/ERC721/extensions/ERC721URIStorage.sol\"; abstract contract ERC721URIStorageMock is ERC721URIStorage { string private _baseTokenURI; function _baseURI() internal view virtual override returns (string memory) { return _baseTokenURI; } function setBaseURI(string calldata newBaseTokenURI) public { _baseTokenURI = newBaseTokenURI; } } ", " pragma solidity ^0.8.20; import {ReentrancyGuard} from \"../utils/ReentrancyGuard.sol\"; import {ReentrancyAttack} from \"./ReentrancyAttack.sol\"; contract ReentrancyMock is ReentrancyGuard { uint256 public counter; constructor() { counter = 0; } function callback() external nonReentrant { _count(); } function viewCallback() external view nonReentrantView returns (uint256) { return counter; } function countLocalRecursive(uint256 n) public nonReentrant { if (n > 0) { _count(); countLocalRecursive(n - 1); } } function countThisRecursive(uint256 n) public nonReentrant { if (n > 0) { _count(); (bool success, ) = address(this).call(abi.encodeCall(this.countThisRecursive, (n - 1))); require(success, \"ReentrancyMock: failed call\"); } } function countAndCall(ReentrancyAttack attacker) public nonReentrant { _count(); attacker.callSender(abi.encodeCall(this.callback, ())); } function countAndCallView(ReentrancyAttack attacker) public nonReentrant { _count(); attacker.staticcallSender(abi.encodeCall(this.viewCallback, ())); } function _count() private { counter += 1; } function guardedCheckEntered() public nonReentrant { require(_reentrancyGuardEntered()); } function unguardedCheckNotEntered() public view { require(!_reentrancyGuardEntered()); } } ", " pragma solidity ^0.8.24; import {Governor} from \"../../governance/Governor.sol\"; import {GovernorSettings} from \"../../governance/extensions/GovernorSettings.sol\"; import {GovernorCountingSimple} from \"../../governance/extensions/GovernorCountingSimple.sol\"; import {GovernorVotesQuorumFraction} from \"../../governance/extensions/GovernorVotesQuorumFraction.sol\"; import {GovernorProposalGuardian} from \"../../governance/extensions/GovernorProposalGuardian.sol\"; abstract contract GovernorProposalGuardianMock is GovernorSettings, GovernorVotesQuorumFraction, GovernorCountingSimple, GovernorProposalGuardian { function proposalThreshold() public view override(Governor, GovernorSettings) returns (uint256) { return super.proposalThreshold(); } function _validateCancel( uint256 proposalId, address caller ) internal view override(Governor, GovernorProposalGuardian) returns (bool) { return super._validateCancel(proposalId, caller); } } ", " pragma solidity ^0.8.24; import {Governor} from \"../../governance/Governor.sol\"; import {GovernorSettings} from \"../../governance/extensions/GovernorSettings.sol\"; import {GovernorSuperQuorum} from \"../../governance/extensions/GovernorSuperQuorum.sol\"; import {GovernorCountingSimple} from \"../../governance/extensions/GovernorCountingSimple.sol\"; import {GovernorVotesSuperQuorumFraction} from \"../../governance/extensions/GovernorVotesSuperQuorumFraction.sol\"; abstract contract GovernorVotesSuperQuorumFractionMock is GovernorSettings, GovernorVotesSuperQuorumFraction, GovernorCountingSimple { function proposalThreshold() public view override(Governor, GovernorSettings) returns (uint256) { return super.proposalThreshold(); } function proposalVotes( uint256 proposalId ) public view virtual override(GovernorCountingSimple, GovernorSuperQuorum) returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes) { return super.proposalVotes(proposalId); } function state( uint256 proposalId ) public view override(Governor, GovernorVotesSuperQuorumFraction) returns (ProposalState) { return super.state(proposalId); } } ", " pragma solidity ^0.8.20; import {ERC20} from \"../../token/ERC20/ERC20.sol\"; contract ERC20Mock is ERC20 { constructor() ERC20(\"ERC20Mock\", \"E20M\") {} function mint(address account, uint256 amount) external { _mint(account, amount); } function burn(address account, uint256 amount) external { _burn(account, amount); } } ", " pragma solidity ^0.8.24; import {Governor} from \"../../governance/Governor.sol\"; import {GovernorSettings} from \"../../governance/extensions/GovernorSettings.sol\"; import {GovernorCountingSimple} from \"../../governance/extensions/GovernorCountingSimple.sol\"; import {GovernorVotesQuorumFraction} from \"../../governance/extensions/GovernorVotesQuorumFraction.sol\"; abstract contract GovernorMock is GovernorSettings, GovernorVotesQuorumFraction, GovernorCountingSimple { function proposalThreshold() public view override(Governor, GovernorSettings) returns (uint256) { return super.proposalThreshold(); } } ", " pragma solidity ^0.8.20; import {ERC1363} from \"../../token/ERC20/extensions/ERC1363.sol\"; abstract contract ERC1363ForceApproveMock is ERC1363 { function approveAndCall(address spender, uint256 amount, bytes memory data) public virtual override returns (bool) { require(amount == 0 || allowance(msg.sender, spender) == 0, \"USDT approval failure\"); return super.approveAndCall(spender, amount, data); } } ", " pragma solidity ^0.8.20; import {ERC20} from \"../../token/ERC20/ERC20.sol\"; abstract contract ERC20DecimalsMock is ERC20 { uint8 private immutable _decimals; constructor(uint8 decimals_) { _decimals = decimals_; } function decimals() public view override returns (uint8) { return _decimals; } } ", " pragma solidity ^0.8.20; import {Multicall} from \"../utils/Multicall.sol\"; import {StorageSlot} from \"../utils/StorageSlot.sol\"; contract StorageSlotMock is Multicall { using StorageSlot for *; function setAddressSlot(bytes32 slot, address value) public { slot.getAddressSlot().value = value; } function setBooleanSlot(bytes32 slot, bool value) public { slot.getBooleanSlot().value = value; } function setBytes32Slot(bytes32 slot, bytes32 value) public { slot.getBytes32Slot().value = value; } function setUint256Slot(bytes32 slot, uint256 value) public { slot.getUint256Slot().value = value; } function setInt256Slot(bytes32 slot, int256 value) public { slot.getInt256Slot().value = value; } function getAddressSlot(bytes32 slot) public view returns (address) { return slot.getAddressSlot().value; } function getBooleanSlot(bytes32 slot) public view returns (bool) { return slot.getBooleanSlot().value; } function getBytes32Slot(bytes32 slot) public view returns (bytes32) { return slot.getBytes32Slot().value; } function getUint256Slot(bytes32 slot) public view returns (uint256) { return slot.getUint256Slot().value; } function getInt256Slot(bytes32 slot) public view returns (int256) { return slot.getInt256Slot().value; } mapping(uint256 key => string) public stringMap; function setStringSlot(bytes32 slot, string calldata value) public { slot.getStringSlot().value = value; } function setStringStorage(uint256 key, string calldata value) public { stringMap[key].getStringSlot().value = value; } function getStringSlot(bytes32 slot) public view returns (string memory) { return slot.getStringSlot().value; } function getStringStorage(uint256 key) public view returns (string memory) { return stringMap[key].getStringSlot().value; } mapping(uint256 key => bytes) public bytesMap; function setBytesSlot(bytes32 slot, bytes calldata value) public { slot.getBytesSlot().value = value; } function setBytesStorage(uint256 key, bytes calldata value) public { bytesMap[key].getBytesSlot().value = value; } function getBytesSlot(bytes32 slot) public view returns (bytes memory) { return slot.getBytesSlot().value; } function getBytesStorage(uint256 key) public view returns (bytes memory) { return bytesMap[key].getBytesSlot().value; } } ", " pragma solidity ^0.8.26; import {Accumulators} from \"../utils/structs/Accumulators.sol\"; import {Address} from \"../utils/Address.sol\"; import {Arrays} from \"../utils/Arrays.sol\"; import {AuthorityUtils} from \"../access/manager/AuthorityUtils.sol\"; import {Base58} from \"../utils/Base58.sol\"; import {Base64} from \"../utils/Base64.sol\"; import {BitMaps} from \"../utils/structs/BitMaps.sol\"; import {Blockhash} from \"../utils/Blockhash.sol\"; import {Bytes} from \"../utils/Bytes.sol\"; import {CAIP2} from \"../utils/CAIP2.sol\"; import {CAIP10} from \"../utils/CAIP10.sol\"; import {Checkpoints} from \"../utils/structs/Checkpoints.sol\"; import {CircularBuffer} from \"../utils/structs/CircularBuffer.sol\"; import {Clones} from \"../proxy/Clones.sol\"; import {Create2} from \"../utils/Create2.sol\"; import {DoubleEndedQueue} from \"../utils/structs/DoubleEndedQueue.sol\"; import {ECDSA} from \"../utils/cryptography/ECDSA.sol\"; import {EIP7702Utils} from \"../account/utils/EIP7702Utils.sol\"; import {EnumerableMap} from \"../utils/structs/EnumerableMap.sol\"; import {EnumerableSet} from \"../utils/structs/EnumerableSet.sol\"; import {ERC165} from \"../utils/introspection/ERC165.sol\"; import {ERC165Checker} from \"../utils/introspection/ERC165Checker.sol\"; import {ERC721Holder} from \"../token/ERC721/utils/ERC721Holder.sol\"; import {ERC1155Holder} from \"../token/ERC1155/utils/ERC1155Holder.sol\"; import {ERC1967Utils} from \"../proxy/ERC1967/ERC1967Utils.sol\"; import {ERC4337Utils} from \"../account/utils/draft-ERC4337Utils.sol\"; import {ERC7579Utils} from \"../account/utils/draft-ERC7579Utils.sol\"; import {ERC7913P256Verifier} from \"../utils/cryptography/verifiers/ERC7913P256Verifier.sol\"; import {ERC7913RSAVerifier} from \"../utils/cryptography/verifiers/ERC7913RSAVerifier.sol\"; import {ERC7913WebAuthnVerifier} from \"../utils/cryptography/verifiers/ERC7913WebAuthnVerifier.sol\"; import {Heap} from \"../utils/structs/Heap.sol\"; import {InteroperableAddress} from \"../utils/draft-InteroperableAddress.sol\"; import {LowLevelCall} from \"../utils/LowLevelCall.sol\"; import {Math} from \"../utils/math/Math.sol\"; import {Memory} from \"../utils/Memory.sol\"; import {MerkleProof} from \"../utils/cryptography/MerkleProof.sol\"; import {MessageHashUtils} from \"../utils/cryptography/MessageHashUtils.sol\"; import {Nonces} from \"../utils/Nonces.sol\"; import {NoncesKeyed} from \"../utils/NoncesKeyed.sol\"; import {P256} from \"../utils/cryptography/P256.sol\"; import {Packing} from \"../utils/Packing.sol\"; import {Panic} from \"../utils/Panic.sol\"; import {RelayedCall} from \"../utils/RelayedCall.sol\"; import {RLP} from \"../utils/RLP.sol\"; import {RSA} from \"../utils/cryptography/RSA.sol\"; import {SafeCast} from \"../utils/math/SafeCast.sol\"; import {SafeERC20} from \"../token/ERC20/utils/SafeERC20.sol\"; import {ShortStrings} from \"../utils/ShortStrings.sol\"; import {SignatureChecker} from \"../utils/cryptography/SignatureChecker.sol\"; import {SignedMath} from \"../utils/math/SignedMath.sol\"; import {StorageSlot} from \"../utils/StorageSlot.sol\"; import {Strings} from \"../utils/Strings.sol\"; import {Time} from \"../utils/types/Time.sol\"; contract Dummy1234 {} ", " pragma solidity ^0.8.20; import {ERC4626Fees} from \"../docs/ERC4626Fees.sol\"; abstract contract ERC4626FeesMock is ERC4626Fees { uint256 private immutable _entryFeeBasisPointValue; address private immutable _entryFeeRecipientValue; uint256 private immutable _exitFeeBasisPointValue; address private immutable _exitFeeRecipientValue; constructor( uint256 entryFeeBasisPoints, address entryFeeRecipient, uint256 exitFeeBasisPoints, address exitFeeRecipient ) { _entryFeeBasisPointValue = entryFeeBasisPoints; _entryFeeRecipientValue = entryFeeRecipient; _exitFeeBasisPointValue = exitFeeBasisPoints; _exitFeeRecipientValue = exitFeeRecipient; } function _entryFeeBasisPoints() internal view virtual override returns (uint256) { return _entryFeeBasisPointValue; } function _entryFeeRecipient() internal view virtual override returns (address) { return _entryFeeRecipientValue; } function _exitFeeBasisPoints() internal view virtual override returns (uint256) { return _exitFeeBasisPointValue; } function _exitFeeRecipient() internal view virtual override returns (address) { return _exitFeeRecipientValue; } } ", " pragma solidity ^0.8.20; import {IERC20} from \"../../token/ERC20/IERC20.sol\"; import {ERC4626} from \"../../token/ERC20/extensions/ERC4626.sol\"; import {SafeERC20} from \"../../token/ERC20/utils/SafeERC20.sol\"; import {Math} from \"../../utils/math/Math.sol\"; abstract contract ERC4626Fees is ERC4626 { using Math for uint256; uint256 private constant _BASIS_POINT_SCALE = 1e4; function previewDeposit(uint256 assets) public view virtual override returns (uint256) { uint256 fee = _feeOnTotal(assets, _entryFeeBasisPoints()); return super.previewDeposit(assets - fee); } function previewMint(uint256 shares) public view virtual override returns (uint256) { uint256 assets = super.previewMint(shares); return assets + _feeOnRaw(assets, _entryFeeBasisPoints()); } function previewWithdraw(uint256 assets) public view virtual override returns (uint256) { uint256 fee = _feeOnRaw(assets, _exitFeeBasisPoints()); return super.previewWithdraw(assets + fee); } function previewRedeem(uint256 shares) public view virtual override returns (uint256) { uint256 assets = super.previewRedeem(shares); return assets - _feeOnTotal(assets, _exitFeeBasisPoints()); } function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal virtual override { uint256 fee = _feeOnTotal(assets, _entryFeeBasisPoints()); address recipient = _entryFeeRecipient(); super._deposit(caller, receiver, assets, shares); if (fee > 0 && recipient != address(this)) { SafeERC20.safeTransfer(IERC20(asset()), recipient, fee); } } function _withdraw( address caller, address receiver, address owner, uint256 assets, uint256 shares ) internal virtual override { uint256 fee = _feeOnRaw(assets, _exitFeeBasisPoints()); address recipient = _exitFeeRecipient(); super._withdraw(caller, receiver, owner, assets, shares); if (fee > 0 && recipient != address(this)) { SafeERC20.safeTransfer(IERC20(asset()), recipient, fee); } } function _entryFeeBasisPoints() internal view virtual returns (uint256) { return 0; } function _exitFeeBasisPoints() internal view virtual returns (uint256) { return 0; } function _entryFeeRecipient() internal view virtual returns (address) { return address(0); } function _exitFeeRecipient() internal view virtual returns (address) { return address(0); } function _feeOnRaw(uint256 assets, uint256 feeBasisPoints) private pure returns (uint256) { return assets.mulDiv(feeBasisPoints, _BASIS_POINT_SCALE, Math.Rounding.Ceil); } function _feeOnTotal(uint256 assets, uint256 feeBasisPoints) private pure returns (uint256) { return assets.mulDiv(feeBasisPoints, feeBasisPoints + _BASIS_POINT_SCALE, Math.Rounding.Ceil); } } ", " pragma solidity ^0.8.24; import {Governor} from \"../../governance/Governor.sol\"; import {GovernorSettings} from \"../../governance/extensions/GovernorSettings.sol\"; import {GovernorVotesQuorumFraction} from \"../../governance/extensions/GovernorVotesQuorumFraction.sol\"; import {GovernorCountingOverridable} from \"../../governance/extensions/GovernorCountingOverridable.sol\"; abstract contract GovernorCountingOverridableMock is GovernorSettings, GovernorVotesQuorumFraction, GovernorCountingOverridable { function proposalThreshold() public view override(Governor, GovernorSettings) returns (uint256) { return super.proposalThreshold(); } } ", " pragma solidity ^0.8.24; import {Governor} from \"../../governance/Governor.sol\"; import {GovernorTimelockCompound} from \"../../governance/extensions/GovernorTimelockCompound.sol\"; import {GovernorSettings} from \"../../governance/extensions/GovernorSettings.sol\"; import {GovernorCountingSimple} from \"../../governance/extensions/GovernorCountingSimple.sol\"; import {GovernorVotesQuorumFraction} from \"../../governance/extensions/GovernorVotesQuorumFraction.sol\"; abstract contract GovernorTimelockCompoundMock is GovernorSettings, GovernorTimelockCompound, GovernorVotesQuorumFraction, GovernorCountingSimple { function quorum(uint256 blockNumber) public view override(Governor, GovernorVotesQuorumFraction) returns (uint256) { return super.quorum(blockNumber); } function state( uint256 proposalId ) public view override(Governor, GovernorTimelockCompound) returns (ProposalState) { return super.state(proposalId); } function proposalThreshold() public view override(Governor, GovernorSettings) returns (uint256) { return super.proposalThreshold(); } function proposalNeedsQueuing( uint256 proposalId ) public view virtual override(Governor, GovernorTimelockCompound) returns (bool) { return super.proposalNeedsQueuing(proposalId); } function _queueOperations( uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) internal override(Governor, GovernorTimelockCompound) returns (uint48) { return super._queueOperations(proposalId, targets, values, calldatas, descriptionHash); } function _executeOperations( uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) internal override(Governor, GovernorTimelockCompound) { super._executeOperations(proposalId, targets, values, calldatas, descriptionHash); } function _cancel( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) internal override(Governor, GovernorTimelockCompound) returns (uint256) { return super._cancel(targets, values, calldatas, descriptionHash); } function _executor() internal view override(Governor, GovernorTimelockCompound) returns (address) { return super._executor(); } } ", " pragma solidity ^0.8.20; import {MerkleTree} from \"../utils/structs/MerkleTree.sol\"; contract MerkleTreeMock { using MerkleTree for MerkleTree.Bytes32PushTree; MerkleTree.Bytes32PushTree private _tree; bytes32 public root; event LeafInserted(bytes32 leaf, uint256 index, bytes32 root); event LeafUpdated(bytes32 oldLeaf, bytes32 newLeaf, uint256 index, bytes32 root); function setup(uint8 _depth, bytes32 _zero) public { root = _tree.setup(_depth, _zero); } function push(bytes32 leaf) public { (uint256 leafIndex, bytes32 currentRoot) = _tree.push(leaf); emit LeafInserted(leaf, leafIndex, currentRoot); root = currentRoot; } function update(uint256 index, bytes32 oldValue, bytes32 newValue, bytes32[] memory proof) public { (bytes32 oldRoot, bytes32 newRoot) = _tree.update(index, oldValue, newValue, proof); if (oldRoot != root) revert MerkleTree.MerkleTreeUpdateInvalidProof(); emit LeafUpdated(oldValue, newValue, index, newRoot); root = newRoot; } function depth() public view returns (uint256) { return _tree.depth(); } function nextLeafIndex() public view returns (uint256) { return _tree._nextLeafIndex; } function sides(uint256 i) public view returns (bytes32) { return _tree._sides[i]; } function zeros(uint256 i) public view returns (bytes32) { return _tree._zeros[i]; } } ", " pragma solidity ^0.8.24; import {ERC20Permit} from \"../../token/ERC20/extensions/ERC20Permit.sol\"; import {Math} from \"../../utils/math/Math.sol\"; import {IVotes} from \"../../governance/utils/IVotes.sol\"; import {SafeCast} from \"../../utils/math/SafeCast.sol\"; import {ECDSA} from \"../../utils/cryptography/ECDSA.sol\"; abstract contract ERC20VotesLegacyMock is IVotes, ERC20Permit { struct Checkpoint { uint32 fromBlock; uint224 votes; } bytes32 private constant _DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\"); mapping(address account => address) private _delegatee; mapping(address delegatee => Checkpoint[]) private _checkpoints; Checkpoint[] private _totalSupplyCheckpoints; function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) { return _checkpoints[account][pos]; } function numCheckpoints(address account) public view virtual returns (uint32) { return SafeCast.toUint32(_checkpoints[account].length); } function delegates(address account) public view virtual returns (address) { return _delegatee[account]; } function getVotes(address account) public view virtual returns (uint256) { uint256 pos = _checkpoints[account].length; unchecked { return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes; } } function getPastVotes(address account, uint256 blockNumber) public view virtual returns (uint256) { require(blockNumber < block.number, \"ERC20Votes: block not yet mined\"); return _checkpointsLookup(_checkpoints[account], blockNumber); } function getPastTotalSupply(uint256 blockNumber) public view virtual returns (uint256) { require(blockNumber < block.number, \"ERC20Votes: block not yet mined\"); return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber); } function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) { uint256 length = ckpts.length; uint256 low = 0; uint256 high = length; if (length > 5) { uint256 mid = length - Math.sqrt(length); if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) { high = mid; } else { low = mid + 1; } } while (low < high) { uint256 mid = Math.average(low, high); if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) { high = mid; } else { low = mid + 1; } } unchecked { return high == 0 ? 0 : _unsafeAccess(ckpts, high - 1).votes; } } function delegate(address delegatee) public virtual { _delegate(_msgSender(), delegatee); } function delegateBySig( address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s ) public virtual { require(block.timestamp <= expiry, \"ERC20Votes: signature expired\"); address signer = ECDSA.recover( _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))), v, r, s ); require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\"); _delegate(signer, delegatee); } function _maxSupply() internal view virtual returns (uint224) { return type(uint224).max; } function _update(address from, address to, uint256 amount) internal virtual override { super._update(from, to, amount); if (from == address(0)) { require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\"); _writeCheckpoint(_totalSupplyCheckpoints, _add, amount); } if (to == address(0)) { _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount); } _moveVotingPower(delegates(from), delegates(to), amount); } function _delegate(address delegator, address delegatee) internal virtual { address currentDelegate = delegates(delegator); uint256 delegatorBalance = balanceOf(delegator); _delegatee[delegator] = delegatee; emit DelegateChanged(delegator, currentDelegate, delegatee); _moveVotingPower(currentDelegate, delegatee, delegatorBalance); } function _moveVotingPower(address src, address dst, uint256 amount) private { if (src != dst && amount > 0) { if (src != address(0)) { (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount); emit DelegateVotesChanged(src, oldWeight, newWeight); } if (dst != address(0)) { (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount); emit DelegateVotesChanged(dst, oldWeight, newWeight); } } } function _writeCheckpoint( Checkpoint[] storage ckpts, function(uint256, uint256) view returns (uint256) op, uint256 delta ) private returns (uint256 oldWeight, uint256 newWeight) { uint256 pos = ckpts.length; unchecked { Checkpoint memory oldCkpt = pos == 0 ? Checkpoint(0, 0) : _unsafeAccess(ckpts, pos - 1); oldWeight = oldCkpt.votes; newWeight = op(oldWeight, delta); if (pos > 0 && oldCkpt.fromBlock == block.number) { _unsafeAccess(ckpts, pos - 1).votes = SafeCast.toUint224(newWeight); } else { ckpts.push( Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)}) ); } } } function _add(uint256 a, uint256 b) private pure returns (uint256) { return a + b; } function _subtract(uint256 a, uint256 b) private pure returns (uint256) { return a - b; } function _unsafeAccess(Checkpoint[] storage ckpts, uint256 pos) private pure returns (Checkpoint storage result) { assembly { mstore(0, ckpts.slot) result.slot := add(keccak256(0, 0x20), pos) } } } ", " pragma solidity ^0.8.20; import {Context} from \"../utils/Context.sol\"; contract ContextMock is Context { event Sender(address sender); function msgSender() public { emit Sender(_msgSender()); } event Data(bytes data, uint256 integerValue, string stringValue); function msgData(uint256 integerValue, string memory stringValue) public { emit Data(_msgData(), integerValue, stringValue); } event DataShort(bytes data); function msgDataShort() public { emit DataShort(_msgData()); } } contract ContextMockCaller { function callSender(ContextMock context) public { context.msgSender(); } function callData(ContextMock context, uint256 integerValue, string memory stringValue) public { context.msgData(integerValue, stringValue); } } ", " pragma solidity ^0.8.20; import {IERC20, ERC20} from \"../../token/ERC20/ERC20.sol\"; import {ERC1363} from \"../../token/ERC20/extensions/ERC1363.sol\"; abstract contract ERC1363ReturnFalseOnERC20Mock is ERC1363 { function transfer(address, uint256) public pure override(IERC20, ERC20) returns (bool) { return false; } function transferFrom(address, address, uint256) public pure override(IERC20, ERC20) returns (bool) { return false; } function approve(address, uint256) public pure override(IERC20, ERC20) returns (bool) { return false; } } abstract contract ERC1363ReturnFalseMock is ERC1363 { function transferAndCall(address, uint256, bytes memory) public pure override returns (bool) { return false; } function transferFromAndCall(address, address, uint256, bytes memory) public pure override returns (bool) { return false; } function approveAndCall(address, uint256, bytes memory) public pure override returns (bool) { return false; } } ", " pragma solidity ^0.8.20; import {ERC4626} from \"../../token/ERC20/extensions/ERC4626.sol\"; abstract contract ERC4626LimitsMock is ERC4626 { uint256 _maxDeposit; uint256 _maxMint; constructor() { _maxDeposit = 100 ether; _maxMint = 100 ether; } function maxDeposit(address) public view override returns (uint256) { return _maxDeposit; } function maxMint(address) public view override returns (uint256) { return _maxMint; } } ", " pragma solidity ^0.8.20; import {ERC1363} from \"../../token/ERC20/extensions/ERC1363.sol\"; abstract contract ERC1363NoReturnMock is ERC1363 { function transferAndCall(address to, uint256 value, bytes memory data) public override returns (bool) { super.transferAndCall(to, value, data); assembly { return(0, 0) } } function transferFromAndCall( address from, address to, uint256 value, bytes memory data ) public override returns (bool) { super.transferFromAndCall(from, to, value, data); assembly { return(0, 0) } } function approveAndCall(address spender, uint256 value, bytes memory data) public override returns (bool) { super.approveAndCall(spender, value, data); assembly { return(0, 0) } } } ", " pragma solidity ^0.8.20; import {IERC1363Spender} from \"../../interfaces/IERC1363Spender.sol\"; contract ERC1363SpenderMock is IERC1363Spender { enum RevertType { None, RevertWithoutMessage, RevertWithMessage, RevertWithCustomError, Panic } bytes4 private _retval; RevertType private _error; event Approved(address owner, uint256 value, bytes data); error CustomError(bytes4); constructor() { _retval = IERC1363Spender.onApprovalReceived.selector; _error = RevertType.None; } function setUp(bytes4 retval, RevertType error) public { _retval = retval; _error = error; } function onApprovalReceived(address owner, uint256 value, bytes calldata data) external override returns (bytes4) { if (_error == RevertType.RevertWithoutMessage) { revert(); } else if (_error == RevertType.RevertWithMessage) { revert(\"ERC1363SpenderMock: reverting\"); } else if (_error == RevertType.RevertWithCustomError) { revert CustomError(_retval); } else if (_error == RevertType.Panic) { uint256 a = uint256(0) / uint256(0); a; } emit Approved(owner, value, data); return _retval; } } ", " pragma solidity ^0.8.20; import {ERC20} from \"../../token/ERC20/ERC20.sol\"; import {Address} from \"../../utils/Address.sol\"; contract ERC20Reentrant is ERC20(\"TEST\", \"TST\") { enum Type { No, Before, After } Type private _reenterType; address private _reenterTarget; bytes private _reenterData; function scheduleReenter(Type when, address target, bytes calldata data) external { _reenterType = when; _reenterTarget = target; _reenterData = data; } function functionCall(address target, bytes memory data) public returns (bytes memory) { return Address.functionCall(target, data); } function _update(address from, address to, uint256 amount) internal override { if (_reenterType == Type.Before) { _reenterType = Type.No; functionCall(_reenterTarget, _reenterData); } super._update(from, to, amount); if (_reenterType == Type.After) { _reenterType = Type.No; functionCall(_reenterTarget, _reenterData); } } } ", " pragma solidity ^0.8.20; contract ClashingImplementation { event ClashingImplementationCall(); function upgradeToAndCall(address, bytes calldata) external payable { emit ClashingImplementationCall(); } function delegatedFunction() external pure returns (bool) { return true; } } ", " pragma solidity ^0.8.20; import {Initializable} from \"../proxy/utils/Initializable.sol\"; contract SampleHuman is Initializable { bool public isHuman; function initialize() public initializer { __SampleHuman_init(); } function __SampleHuman_init() internal onlyInitializing { __SampleHuman_init_unchained(); } function __SampleHuman_init_unchained() internal onlyInitializing { isHuman = true; } } contract SampleMother is Initializable, SampleHuman { uint256 public mother; function initialize(uint256 value) public initializer { __SampleMother_init(value); } function __SampleMother_init(uint256 value) internal onlyInitializing { __SampleHuman_init(); __SampleMother_init_unchained(value); } function __SampleMother_init_unchained(uint256 value) internal onlyInitializing { mother = value; } } contract SampleGramps is Initializable, SampleHuman { string public gramps; function initialize(string memory value) public initializer { __SampleGramps_init(value); } function __SampleGramps_init(string memory value) internal onlyInitializing { __SampleHuman_init(); __SampleGramps_init_unchained(value); } function __SampleGramps_init_unchained(string memory value) internal onlyInitializing { gramps = value; } } contract SampleFather is Initializable, SampleGramps { uint256 public father; function initialize(string memory _gramps, uint256 _father) public initializer { __SampleFather_init(_gramps, _father); } function __SampleFather_init(string memory _gramps, uint256 _father) internal onlyInitializing { __SampleGramps_init(_gramps); __SampleFather_init_unchained(_father); } function __SampleFather_init_unchained(uint256 _father) internal onlyInitializing { father = _father; } } contract SampleChild is Initializable, SampleMother, SampleFather { uint256 public child; function initialize(uint256 _mother, string memory _gramps, uint256 _father, uint256 _child) public initializer { __SampleChild_init(_mother, _gramps, _father, _child); } function __SampleChild_init( uint256 _mother, string memory _gramps, uint256 _father, uint256 _child ) internal onlyInitializing { __SampleMother_init(_mother); __SampleFather_init(_gramps, _father); __SampleChild_init_unchained(_child); } function __SampleChild_init_unchained(uint256 _child) internal onlyInitializing { child = _child; } } ", " pragma solidity ^0.8.24; import {ReentrancyGuardTransient} from \"../utils/ReentrancyGuardTransient.sol\"; import {ReentrancyAttack} from \"./ReentrancyAttack.sol\"; contract ReentrancyTransientMock is ReentrancyGuardTransient { uint256 public counter; constructor() { counter = 0; } function callback() external nonReentrant { _count(); } function viewCallback() external view nonReentrantView returns (uint256) { return counter; } function countLocalRecursive(uint256 n) public nonReentrant { if (n > 0) { _count(); countLocalRecursive(n - 1); } } function countThisRecursive(uint256 n) public nonReentrant { if (n > 0) { _count(); (bool success, ) = address(this).call(abi.encodeCall(this.countThisRecursive, (n - 1))); require(success, \"ReentrancyTransientMock: failed call\"); } } function countAndCall(ReentrancyAttack attacker) public nonReentrant { _count(); attacker.callSender(abi.encodeCall(this.callback, ())); } function countAndCallView(ReentrancyAttack attacker) public nonReentrant { _count(); attacker.staticcallSender(abi.encodeCall(this.viewCallback, ())); } function _count() private { counter += 1; } function guardedCheckEntered() public nonReentrant { require(_reentrancyGuardEntered()); } function unguardedCheckNotEntered() public view { require(!_reentrancyGuardEntered()); } } ", " pragma solidity ^0.8.24; import {ERC721} from \"../../token/ERC721/ERC721.sol\"; contract MyNFT is ERC721 { constructor() ERC721(\"MyNFT\", \"MNFT\") {} } ", " pragma solidity ^0.8.24; import {ERC721} from \"../../token/ERC721/ERC721.sol\"; import {ERC721Consecutive} from \"../../token/ERC721/extensions/ERC721Consecutive.sol\"; import {ERC721Pausable} from \"../../token/ERC721/extensions/ERC721Pausable.sol\"; import {ERC721Votes} from \"../../token/ERC721/extensions/ERC721Votes.sol\"; import {EIP712} from \"../../utils/cryptography/EIP712.sol\"; contract ERC721ConsecutiveMock is ERC721Consecutive, ERC721Pausable, ERC721Votes { uint96 private immutable _offset; constructor( string memory name, string memory symbol, uint96 offset, address[] memory delegates, address[] memory receivers, uint96[] memory amounts ) ERC721(name, symbol) EIP712(name, \"1\") { _offset = offset; for (uint256 i = 0; i < delegates.length; ++i) { _delegate(delegates[i], delegates[i]); } for (uint256 i = 0; i < receivers.length; ++i) { _mintConsecutive(receivers[i], amounts[i]); } } function _firstConsecutiveId() internal view virtual override returns (uint96) { return _offset; } function _ownerOf(uint256 tokenId) internal view virtual override(ERC721, ERC721Consecutive) returns (address) { return super._ownerOf(tokenId); } function _update( address to, uint256 tokenId, address auth ) internal virtual override(ERC721Consecutive, ERC721Pausable, ERC721Votes) returns (address) { return super._update(to, tokenId, auth); } function _increaseBalance(address account, uint128 amount) internal virtual override(ERC721, ERC721Votes) { super._increaseBalance(account, amount); } } contract ERC721ConsecutiveNoConstructorMintMock is ERC721Consecutive { constructor(string memory name, string memory symbol) ERC721(name, symbol) { _mint(msg.sender, 0); } } ", " pragma solidity ^0.8.20; import {ERC20Bridgeable} from \"../../token/ERC20/extensions/draft-ERC20Bridgeable.sol\"; abstract contract ERC20BridgeableMock is ERC20Bridgeable { address private _bridge; error OnlyTokenBridge(); event OnlyTokenBridgeFnCalled(address caller); constructor(address bridge) { _bridge = bridge; } function onlyTokenBridgeFn() external onlyTokenBridge { emit OnlyTokenBridgeFnCalled(msg.sender); } function _checkTokenBridge(address sender) internal view override { if (sender != _bridge) { revert OnlyTokenBridge(); } } } ", " pragma solidity ^0.8.20; contract ConstructorMock { bool foo; enum RevertType { None, RevertWithoutMessage, RevertWithMessage, RevertWithCustomError, Panic } error CustomError(); constructor(RevertType error) { foo = true; if (error == RevertType.RevertWithoutMessage) { revert(); } else if (error == RevertType.RevertWithMessage) { revert(\"ConstructorMock: reverting\"); } else if (error == RevertType.RevertWithCustomError) { revert CustomError(); } else if (error == RevertType.Panic) { uint256 a = uint256(0) / uint256(0); a; } } } ", " pragma solidity ^0.8.20; import {ERC20} from \"../../token/ERC20/ERC20.sol\"; import {Multicall} from \"../../utils/Multicall.sol\"; abstract contract ERC20MulticallMock is ERC20, Multicall {} ", " pragma solidity ^0.8.24; import {Governor, Nonces} from \"../../governance/Governor.sol\"; import {GovernorSettings} from \"../../governance/extensions/GovernorSettings.sol\"; import {GovernorCountingSimple} from \"../../governance/extensions/GovernorCountingSimple.sol\"; import {GovernorVotesQuorumFraction} from \"../../governance/extensions/GovernorVotesQuorumFraction.sol\"; import {GovernorNoncesKeyed} from \"../../governance/extensions/GovernorNoncesKeyed.sol\"; abstract contract GovernorNoncesKeyedMock is GovernorSettings, GovernorVotesQuorumFraction, GovernorCountingSimple, GovernorNoncesKeyed { function proposalThreshold() public view override(Governor, GovernorSettings) returns (uint256) { return super.proposalThreshold(); } function _validateVoteSig( uint256 proposalId, uint8 support, address voter, bytes memory signature ) internal virtual override(Governor, GovernorNoncesKeyed) returns (bool) { return super._validateVoteSig(proposalId, support, voter, signature); } function _validateExtendedVoteSig( uint256 proposalId, uint8 support, address voter, string memory reason, bytes memory params, bytes memory signature ) internal virtual override(Governor, GovernorNoncesKeyed) returns (bool) { return super._validateExtendedVoteSig(proposalId, support, voter, reason, params, signature); } function _useCheckedNonce(address owner, uint256 nonce) internal virtual override(Nonces, GovernorNoncesKeyed) { super._useCheckedNonce(owner, nonce); } } ", " pragma solidity ^0.8.20; import {Initializable} from \"../proxy/utils/Initializable.sol\"; contract MigratableMockV1 is Initializable { uint256 public x; function initialize(uint256 value) public payable initializer { x = value; } } contract MigratableMockV2 is MigratableMockV1 { bool internal _migratedV2; uint256 public y; function migrate(uint256 value, uint256 anotherValue) public payable { require(!_migratedV2); x = value; y = anotherValue; _migratedV2 = true; } } contract MigratableMockV3 is MigratableMockV2 { bool internal _migratedV3; function migrate() public payable { require(!_migratedV3); uint256 oldX = x; x = y; y = oldX; _migratedV3 = true; } } ", " pragma solidity ^0.8.20; import {Ownable} from \"../../../access/Ownable.sol\"; contract MyContract is Ownable { constructor(address initialOwner) Ownable(initialOwner) {} function normalThing() public { } function specialThing() public onlyOwner { } } ", " pragma solidity ^0.8.20; import {Address} from \"../utils/Address.sol\"; contract BatchCaller { struct Call { address target; uint256 value; bytes data; } function execute(Call[] calldata calls) external returns (bytes[] memory) { bytes[] memory returndata = new bytes[](calls.length); for (uint256 i = 0; i < calls.length; ++i) { returndata[i] = Address.functionCallWithValue(calls[i].target, calls[i].data, calls[i].value); } return returndata; } } ", " pragma solidity ^0.8.20; import {AccessControl} from \"../../../access/AccessControl.sol\"; import {ERC20} from \"../../../token/ERC20/ERC20.sol\"; contract AccessControlERC20MintBase is ERC20, AccessControl { bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\"); error CallerNotMinter(address caller); constructor(address minter) ERC20(\"MyToken\", \"TKN\") { _grantRole(MINTER_ROLE, minter); } function mint(address to, uint256 amount) public { if (!hasRole(MINTER_ROLE, msg.sender)) { revert CallerNotMinter(msg.sender); } _mint(to, amount); } } ", " pragma solidity ^0.8.20; import {AccessControl} from \"../../../access/AccessControl.sol\"; contract AccessControlModified is AccessControl { error AccessControlNonRevocable(); function revokeRole(bytes32, address) public pure override { revert AccessControlNonRevocable(); } } ", " pragma solidity ^0.8.20; import {ERC20} from \"../../token/ERC20/ERC20.sol\"; abstract contract ERC20NoReturnMock is ERC20 { function transfer(address to, uint256 amount) public override returns (bool) { super.transfer(to, amount); assembly { return(0, 0) } } function transferFrom(address from, address to, uint256 amount) public override returns (bool) { super.transferFrom(from, to, amount); assembly { return(0, 0) } } function approve(address spender, uint256 amount) public override returns (bool) { super.approve(spender, amount); assembly { return(0, 0) } } } ", " pragma solidity ^0.8.0; contract ReentrancyExample { mapping(address => uint256) public balances; function deposit() external payable { balances[msg.sender] += msg.value; } function withdraw(uint256 _amount) external { require(balances[msg.sender] >= _amount, \"Insufficient\"); (bool sent, ) = msg.sender.call{value: _amount}(\"\"); require(sent, \"Failed\"); balances[msg.sender] -= _amount; } } ", " pragma solidity ^0.8.20; import {Address} from \"../utils/Address.sol\"; contract TimelockReentrant { address private _reenterTarget; bytes private _reenterData; bool _reentered; function disableReentrancy() external { _reentered = true; } function enableReentrancy(address target, bytes calldata data) external { _reenterTarget = target; _reenterData = data; } function reenter() external { if (!_reentered) { _reentered = true; Address.functionCall(_reenterTarget, _reenterData); } } } ", " pragma solidity ^0.8.20; import {IERC20} from \"../../token/ERC20/IERC20.sol\"; import {IERC20Metadata} from \"../../token/ERC20/extensions/IERC20Metadata.sol\"; contract ERC20GetterHelper { event ERC20TotalSupply(IERC20 token, uint256 totalSupply); event ERC20BalanceOf(IERC20 token, address account, uint256 balanceOf); event ERC20Allowance(IERC20 token, address owner, address spender, uint256 allowance); event ERC20Name(IERC20Metadata token, string name); event ERC20Symbol(IERC20Metadata token, string symbol); event ERC20Decimals(IERC20Metadata token, uint8 decimals); function totalSupply(IERC20 token) external { emit ERC20TotalSupply(token, token.totalSupply()); } function balanceOf(IERC20 token, address account) external { emit ERC20BalanceOf(token, account, token.balanceOf(account)); } function allowance(IERC20 token, address owner, address spender) external { emit ERC20Allowance(token, owner, spender, token.allowance(owner, spender)); } function name(IERC20Metadata token) external { emit ERC20Name(token, token.name()); } function symbol(IERC20Metadata token) external { emit ERC20Symbol(token, token.symbol()); } function decimals(IERC20Metadata token) external { emit ERC20Decimals(token, token.decimals()); } } ", " pragma solidity ^0.8.20; import {Base64} from \"../utils/Base64.sol\"; contract Base64Dirty { struct A { uint256 value; } function encode(bytes memory input) public pure returns (string memory) { A memory unused = A({value: type(uint256).max}); unused; return Base64.encode(input); } } ", " pragma solidity ^0.8.20; import {AccessManager} from \"../access/manager/AccessManager.sol\"; contract AccessManagerMock is AccessManager { event CalledRestricted(address caller); event CalledUnrestricted(address caller); constructor(address initialAdmin) AccessManager(initialAdmin) {} function fnRestricted() public onlyAuthorized { emit CalledRestricted(msg.sender); } function fnUnrestricted() public { emit CalledUnrestricted(msg.sender); } } ", " pragma solidity ^0.8.20; import {Pausable} from \"../utils/Pausable.sol\"; contract PausableMock is Pausable { bool public drasticMeasureTaken; uint256 public count; constructor() { drasticMeasureTaken = false; count = 0; } function normalProcess() external whenNotPaused { count++; } function drasticMeasure() external whenPaused { drasticMeasureTaken = true; } function pause() external { _pause(); } function unpause() external { _unpause(); } } ", " pragma solidity ^0.8.26; import {Account} from \"../../account/Account.sol\"; import {AccountERC7579} from \"../../account/extensions/draft-AccountERC7579.sol\"; import {AccountERC7579Hooked} from \"../../account/extensions/draft-AccountERC7579Hooked.sol\"; import {ERC721Holder} from \"../../token/ERC721/utils/ERC721Holder.sol\"; import {ERC1155Holder} from \"../../token/ERC1155/utils/ERC1155Holder.sol\"; import {ERC7739} from \"../../utils/cryptography/signers/draft-ERC7739.sol\"; import {ERC7821} from \"../../account/extensions/draft-ERC7821.sol\"; import {MODULE_TYPE_VALIDATOR} from \"../../interfaces/draft-IERC7579.sol\"; import {PackedUserOperation} from \"../../interfaces/draft-IERC4337.sol\"; import {AbstractSigner} from \"../../utils/cryptography/signers/AbstractSigner.sol\"; import {SignerECDSA} from \"../../utils/cryptography/signers/SignerECDSA.sol\"; import {SignerP256} from \"../../utils/cryptography/signers/SignerP256.sol\"; import {SignerRSA} from \"../../utils/cryptography/signers/SignerRSA.sol\"; import {SignerWebAuthn} from \"../../utils/cryptography/signers/SignerWebAuthn.sol\"; import {SignerEIP7702} from \"../../utils/cryptography/signers/SignerEIP7702.sol\"; import {SignerERC7913} from \"../../utils/cryptography/signers/SignerERC7913.sol\"; import {MultiSignerERC7913} from \"../../utils/cryptography/signers/MultiSignerERC7913.sol\"; import {MultiSignerERC7913Weighted} from \"../../utils/cryptography/signers/MultiSignerERC7913Weighted.sol\"; abstract contract AccountMock is Account, ERC7739, ERC7821, ERC721Holder, ERC1155Holder { function _rawSignatureValidation(bytes32 hash, bytes calldata signature) internal pure override returns (bool) { return signature.length >= 32 && bytes32(signature) == hash; } function _erc7821AuthorizedExecutor( address caller, bytes32 mode, bytes calldata executionData ) internal view virtual override returns (bool) { return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData); } } abstract contract AccountECDSAMock is Account, SignerECDSA, ERC7739, ERC7821, ERC721Holder, ERC1155Holder { function _erc7821AuthorizedExecutor( address caller, bytes32 mode, bytes calldata executionData ) internal view virtual override returns (bool) { return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData); } } abstract contract AccountP256Mock is Account, SignerP256, ERC7739, ERC7821, ERC721Holder, ERC1155Holder { function _erc7821AuthorizedExecutor( address caller, bytes32 mode, bytes calldata executionData ) internal view virtual override returns (bool) { return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData); } } abstract contract AccountRSAMock is Account, SignerRSA, ERC7739, ERC7821, ERC721Holder, ERC1155Holder { function _erc7821AuthorizedExecutor( address caller, bytes32 mode, bytes calldata executionData ) internal view virtual override returns (bool) { return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData); } } abstract contract AccountWebAuthnMock is Account, SignerWebAuthn, ERC7739, ERC7821, ERC721Holder, ERC1155Holder { function _erc7821AuthorizedExecutor( address caller, bytes32 mode, bytes calldata executionData ) internal view virtual override returns (bool) { return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData); } } abstract contract AccountERC7702Mock is Account, SignerEIP7702, ERC7739, ERC7821, ERC721Holder, ERC1155Holder { function _erc7821AuthorizedExecutor( address caller, bytes32 mode, bytes calldata executionData ) internal view virtual override returns (bool) { return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData); } } abstract contract AccountERC7702WithModulesMock is Account, AccountERC7579, SignerEIP7702, ERC7739, ERC721Holder, ERC1155Holder { function _validateUserOp( PackedUserOperation calldata userOp, bytes32 userOpHash, bytes calldata signature ) internal virtual override(Account, AccountERC7579) returns (uint256) { return super._validateUserOp(userOp, userOpHash, signature); } function isValidSignature( bytes32 hash, bytes calldata signature ) public view virtual override(ERC7739, AccountERC7579) returns (bytes4) { bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature); return erc7739magic == bytes4(0xffffffff) ? AccountERC7579.isValidSignature(hash, signature) : erc7739magic; } function _rawSignatureValidation( bytes32 hash, bytes calldata signature ) internal view virtual override(AbstractSigner, AccountERC7579, SignerEIP7702) returns (bool) { return SignerEIP7702._rawSignatureValidation(hash, signature); } } abstract contract AccountERC7579Mock is AccountERC7579 { constructor(address validator, bytes memory initData) { _installModule(MODULE_TYPE_VALIDATOR, validator, initData); } } abstract contract AccountERC7579HookedMock is AccountERC7579Hooked { constructor(address validator, bytes memory initData) { _installModule(MODULE_TYPE_VALIDATOR, validator, initData); } } abstract contract AccountERC7913Mock is Account, SignerERC7913, ERC7739, ERC7821, ERC721Holder, ERC1155Holder { function _erc7821AuthorizedExecutor( address caller, bytes32 mode, bytes calldata executionData ) internal view virtual override returns (bool) { return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData); } } abstract contract AccountMultiSignerMock is Account, MultiSignerERC7913, ERC7739, ERC7821, ERC721Holder, ERC1155Holder { function _erc7821AuthorizedExecutor( address caller, bytes32 mode, bytes calldata executionData ) internal view virtual override returns (bool) { return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData); } } abstract contract AccountMultiSignerWeightedMock is Account, MultiSignerERC7913Weighted, ERC7739, ERC7821, ERC721Holder, ERC1155Holder { function _erc7821AuthorizedExecutor( address caller, bytes32 mode, bytes calldata executionData ) internal view virtual override returns (bool) { return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData); } } ", " pragma solidity ^0.8.20; import {CallType, ExecType, ModeSelector, ModePayload} from \"../../../account/utils/draft-ERC7579Utils.sol\"; contract ERC7579UtilsGlobalMock { function eqCallTypeGlobal(CallType callType1, CallType callType2) internal pure returns (bool) { return callType1 == callType2; } function eqExecTypeGlobal(ExecType execType1, ExecType execType2) internal pure returns (bool) { return execType1 == execType2; } function eqModeSelectorGlobal(ModeSelector modeSelector1, ModeSelector modeSelector2) internal pure returns (bool) { return modeSelector1 == modeSelector2; } function eqModePayloadGlobal(ModePayload modePayload1, ModePayload modePayload2) internal pure returns (bool) { return modePayload1 == modePayload2; } } ", " pragma solidity ^0.8.20; import {IBeacon} from \"../proxy/beacon/IBeacon.sol\"; contract UpgradeableBeaconMock is IBeacon { address public implementation; constructor(address impl) { implementation = impl; } } interface IProxyExposed { function $getBeacon() external view returns (address); } contract UpgradeableBeaconReentrantMock is IBeacon { error BeaconProxyBeaconSlotAddress(address beacon); function implementation() external view override returns (address) { revert BeaconProxyBeaconSlotAddress(IProxyExposed(msg.sender).$getBeacon()); } } ", " pragma solidity ^0.8.20; import {IERC721Receiver} from \"../../token/ERC721/IERC721Receiver.sol\"; contract ERC721ReceiverMock is IERC721Receiver { enum RevertType { None, RevertWithoutMessage, RevertWithMessage, RevertWithCustomError, Panic } bytes4 private immutable _retval; RevertType private immutable _error; event Received(address operator, address from, uint256 tokenId, bytes data, uint256 gas); error CustomError(bytes4); constructor(bytes4 retval, RevertType error) { _retval = retval; _error = error; } function onERC721Received( address operator, address from, uint256 tokenId, bytes memory data ) public returns (bytes4) { if (_error == RevertType.RevertWithoutMessage) { revert(); } else if (_error == RevertType.RevertWithMessage) { revert(\"ERC721ReceiverMock: reverting\"); } else if (_error == RevertType.RevertWithCustomError) { revert CustomError(_retval); } else if (_error == RevertType.Panic) { uint256 a = uint256(0) / uint256(0); a; } emit Received(operator, from, tokenId, data, gasleft()); return _retval; } } ", " pragma solidity ^0.8.20; import {IERC1155Receiver} from \"../../token/ERC1155/IERC1155Receiver.sol\"; import {ERC165} from \"../../utils/introspection/ERC165.sol\"; contract ERC1155ReceiverMock is ERC165, IERC1155Receiver { enum RevertType { None, RevertWithoutMessage, RevertWithMessage, RevertWithCustomError, Panic } bytes4 private immutable _recRetval; bytes4 private immutable _batRetval; RevertType private immutable _error; event Received(address operator, address from, uint256 id, uint256 value, bytes data, uint256 gas); event BatchReceived(address operator, address from, uint256[] ids, uint256[] values, bytes data, uint256 gas); error CustomError(bytes4); constructor(bytes4 recRetval, bytes4 batRetval, RevertType error) { _recRetval = recRetval; _batRetval = batRetval; _error = error; } function onERC1155Received( address operator, address from, uint256 id, uint256 value, bytes calldata data ) external returns (bytes4) { if (_error == RevertType.RevertWithoutMessage) { revert(); } else if (_error == RevertType.RevertWithMessage) { revert(\"ERC1155ReceiverMock: reverting on receive\"); } else if (_error == RevertType.RevertWithCustomError) { revert CustomError(_recRetval); } else if (_error == RevertType.Panic) { uint256 a = uint256(0) / uint256(0); a; } emit Received(operator, from, id, value, data, gasleft()); return _recRetval; } function onERC1155BatchReceived( address operator, address from, uint256[] calldata ids, uint256[] calldata values, bytes calldata data ) external returns (bytes4) { if (_error == RevertType.RevertWithoutMessage) { revert(); } else if (_error == RevertType.RevertWithMessage) { revert(\"ERC1155ReceiverMock: reverting on batch receive\"); } else if (_error == RevertType.RevertWithCustomError) { revert CustomError(_recRetval); } else if (_error == RevertType.Panic) { uint256 a = uint256(0) / uint256(0); a; } emit BatchReceived(operator, from, ids, values, data, gasleft()); return _batRetval; } } ", " pragma solidity >=0.5.0; interface IERC777Recipient { function tokensReceived( address operator, address from, address to, uint256 amount, bytes calldata userData, bytes calldata operatorData ) external; } ", " pragma solidity >=0.6.2; import {IERC721Enumerable} from \"../token/ERC721/extensions/IERC721Enumerable.sol\"; ", " pragma solidity ^0.8.24; import {IGovernor, Governor} from \"../Governor.sol\"; import {AuthorityUtils} from \"../../access/manager/AuthorityUtils.sol\"; import {IAccessManager} from \"../../access/manager/IAccessManager.sol\"; import {Address} from \"../../utils/Address.sol\"; import {Math} from \"../../utils/math/Math.sol\"; import {SafeCast} from \"../../utils/math/SafeCast.sol\"; import {Time} from \"../../utils/types/Time.sol\"; abstract contract GovernorTimelockAccess is Governor { struct ExecutionPlan { uint16 length; uint32 delay; mapping(uint256 operationBucket => uint32[8]) managerData; } mapping(address target => mapping(bytes4 selector => bool)) private _ignoreToggle; mapping(uint256 proposalId => ExecutionPlan) private _executionPlan; uint32 private _baseDelay; IAccessManager private immutable _manager; error GovernorUnmetDelay(uint256 proposalId, uint256 neededTimestamp); error GovernorMismatchedNonce(uint256 proposalId, uint256 expectedNonce, uint256 actualNonce); error GovernorLockedIgnore(); event BaseDelaySet(uint32 oldBaseDelaySeconds, uint32 newBaseDelaySeconds); event AccessManagerIgnoredSet(address target, bytes4 selector, bool ignored); constructor(address manager, uint32 initialBaseDelay) { _manager = IAccessManager(manager); _setBaseDelaySeconds(initialBaseDelay); } function accessManager() public view virtual returns (IAccessManager) { return _manager; } function baseDelaySeconds() public view virtual returns (uint32) { return _baseDelay; } function setBaseDelaySeconds(uint32 newBaseDelay) public virtual onlyGovernance { _setBaseDelaySeconds(newBaseDelay); } function _setBaseDelaySeconds(uint32 newBaseDelay) internal virtual { emit BaseDelaySet(_baseDelay, newBaseDelay); _baseDelay = newBaseDelay; } function isAccessManagerIgnored(address target, bytes4 selector) public view virtual returns (bool) { bool isGovernor = target == address(this); return _ignoreToggle[target][selector] != isGovernor; } function setAccessManagerIgnored( address target, bytes4[] calldata selectors, bool ignored ) public virtual onlyGovernance { for (uint256 i = 0; i < selectors.length; ++i) { _setAccessManagerIgnored(target, selectors[i], ignored); } } function _setAccessManagerIgnored(address target, bytes4 selector, bool ignored) internal virtual { bool isGovernor = target == address(this); if (isGovernor && selector == this.setAccessManagerIgnored.selector) { revert GovernorLockedIgnore(); } _ignoreToggle[target][selector] = ignored != isGovernor; emit AccessManagerIgnoredSet(target, selector, ignored); } function proposalExecutionPlan( uint256 proposalId ) public view returns (uint32 delay, bool[] memory indirect, bool[] memory withDelay) { ExecutionPlan storage plan = _executionPlan[proposalId]; uint32 length = plan.length; delay = plan.delay; indirect = new bool[](length); withDelay = new bool[](length); for (uint256 i = 0; i < length; ++i) { (indirect[i], withDelay[i], ) = _getManagerData(plan, i); } return (delay, indirect, withDelay); } function proposalNeedsQueuing(uint256 proposalId) public view virtual override returns (bool) { return _executionPlan[proposalId].delay > 0; } function propose( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, string memory description ) public virtual override returns (uint256) { uint256 proposalId = super.propose(targets, values, calldatas, description); uint32 neededDelay = baseDelaySeconds(); ExecutionPlan storage plan = _executionPlan[proposalId]; plan.length = SafeCast.toUint16(targets.length); for (uint256 i = 0; i < targets.length; ++i) { if (calldatas[i].length < 4) { continue; } address target = targets[i]; bytes4 selector = bytes4(calldatas[i]); (bool immediate, uint32 delay) = AuthorityUtils.canCallWithDelay( address(_manager), address(this), target, selector ); if ((immediate || delay > 0) && !isAccessManagerIgnored(target, selector)) { _setManagerData(plan, i, !immediate, 0); neededDelay = uint32(Math.max(delay, neededDelay)); } } plan.delay = neededDelay; return proposalId; } function _queueOperations( uint256 proposalId, address[] memory targets, uint256[] memory , bytes[] memory calldatas, bytes32 ) internal virtual override returns (uint48) { ExecutionPlan storage plan = _executionPlan[proposalId]; uint48 etaSeconds = Time.timestamp() + plan.delay; for (uint256 i = 0; i < targets.length; ++i) { (, bool withDelay, ) = _getManagerData(plan, i); if (withDelay) { (, uint32 nonce) = _manager.schedule(targets[i], calldatas[i], etaSeconds); _setManagerData(plan, i, true, nonce); } } return etaSeconds; } function _executeOperations( uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 ) internal virtual override { uint48 etaSeconds = SafeCast.toUint48(proposalEta(proposalId)); if (block.timestamp < etaSeconds) { revert GovernorUnmetDelay(proposalId, etaSeconds); } ExecutionPlan storage plan = _executionPlan[proposalId]; for (uint256 i = 0; i < targets.length; ++i) { (bool controlled, bool withDelay, uint32 nonce) = _getManagerData(plan, i); if (controlled) { uint32 executedNonce = _manager.execute{value: values[i]}(targets[i], calldatas[i]); if (withDelay && executedNonce != nonce) { revert GovernorMismatchedNonce(proposalId, nonce, executedNonce); } } else { (bool success, bytes memory returndata) = targets[i].call{value: values[i]}(calldatas[i]); Address.verifyCallResult(success, returndata); } } } function _cancel( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) internal virtual override returns (uint256) { uint256 proposalId = super._cancel(targets, values, calldatas, descriptionHash); uint48 etaSeconds = SafeCast.toUint48(proposalEta(proposalId)); ExecutionPlan storage plan = _executionPlan[proposalId]; if (etaSeconds != 0) { for (uint256 i = 0; i < targets.length; ++i) { (, bool withDelay, uint32 nonce) = _getManagerData(plan, i); if (withDelay) { bytes32 operationId = _manager.hashOperation(address(this), targets[i], calldatas[i]); if (nonce == _manager.getNonce(operationId)) { try _manager.cancel(address(this), targets[i], calldatas[i]) {} catch {} } } } } return proposalId; } function _getManagerData( ExecutionPlan storage plan, uint256 index ) private view returns (bool controlled, bool withDelay, uint32 nonce) { (uint256 bucket, uint256 subindex) = _getManagerDataIndices(index); uint32 value = plan.managerData[bucket][subindex]; unchecked { return (value > 0, value > 1, value > 1 ? value - 2 : 0); } } function _setManagerData(ExecutionPlan storage plan, uint256 index, bool withDelay, uint32 nonce) private { (uint256 bucket, uint256 subindex) = _getManagerDataIndices(index); plan.managerData[bucket][subindex] = withDelay ? nonce + 2 : 1; } function _getManagerDataIndices(uint256 index) private pure returns (uint256 bucket, uint256 subindex) { bucket = index >> 3; subindex = index & 7; } } ", " pragma solidity >=0.6.2; import {IERC721Metadata} from \"../token/ERC721/extensions/IERC721Metadata.sol\"; ", " pragma solidity ^0.8.24; import {IGovernor, Governor} from \"../Governor.sol\"; import {ICompoundTimelock} from \"../../vendor/compound/ICompoundTimelock.sol\"; import {Address} from \"../../utils/Address.sol\"; import {SafeCast} from \"../../utils/math/SafeCast.sol\"; abstract contract GovernorTimelockCompound is Governor { ICompoundTimelock private _timelock; event TimelockChange(address oldTimelock, address newTimelock); constructor(ICompoundTimelock timelockAddress) { _updateTimelock(timelockAddress); } function state(uint256 proposalId) public view virtual override returns (ProposalState) { ProposalState currentState = super.state(proposalId); return (currentState == ProposalState.Queued && block.timestamp >= proposalEta(proposalId) + _timelock.GRACE_PERIOD()) ? ProposalState.Expired : currentState; } function timelock() public view virtual returns (address) { return address(_timelock); } function proposalNeedsQueuing(uint256) public view virtual override returns (bool) { return true; } function _queueOperations( uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 ) internal virtual override returns (uint48) { uint48 etaSeconds = SafeCast.toUint48(block.timestamp + _timelock.delay()); for (uint256 i = 0; i < targets.length; ++i) { if ( _timelock.queuedTransactions(keccak256(abi.encode(targets[i], values[i], \"\", calldatas[i], etaSeconds))) ) { revert GovernorAlreadyQueuedProposal(proposalId); } _timelock.queueTransaction(targets[i], values[i], \"\", calldatas[i], etaSeconds); } return etaSeconds; } function _executeOperations( uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 ) internal virtual override { uint256 etaSeconds = proposalEta(proposalId); if (etaSeconds == 0) { revert GovernorNotQueuedProposal(proposalId); } Address.sendValue(payable(_timelock), msg.value); for (uint256 i = 0; i < targets.length; ++i) { _timelock.executeTransaction(targets[i], values[i], \"\", calldatas[i], etaSeconds); } } function _cancel( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) internal virtual override returns (uint256) { uint256 proposalId = super._cancel(targets, values, calldatas, descriptionHash); uint256 etaSeconds = proposalEta(proposalId); if (etaSeconds > 0) { for (uint256 i = 0; i < targets.length; ++i) { _timelock.cancelTransaction(targets[i], values[i], \"\", calldatas[i], etaSeconds); } } return proposalId; } function _executor() internal view virtual override returns (address) { return address(_timelock); } function __acceptAdmin() public { _timelock.acceptAdmin(); } function updateTimelock(ICompoundTimelock newTimelock) public virtual onlyGovernance { _updateTimelock(newTimelock); } function _updateTimelock(ICompoundTimelock newTimelock) private { emit TimelockChange(address(_timelock), address(newTimelock)); _timelock = newTimelock; } } ", " pragma solidity >=0.4.16; import {IERC20} from \"../token/ERC20/IERC20.sol\"; ", " pragma solidity ^0.8.0; contract SafeBank { mapping(address => uint256) public balances; function deposit() external payable { balances[msg.sender] += msg.value; } function withdraw(uint256 _amount) external { require(balances[msg.sender] >= _amount, \"Insufficient\"); balances[msg.sender] -= _amount; payable(msg.sender).transfer(_amount); } } ", " pragma solidity >=0.8.4; interface IERC7751 { error WrappedError(address target, bytes4 selector, bytes reason, bytes details); } ", " pragma solidity ^0.8.24; import {Governor} from \"../Governor.sol\"; abstract contract GovernorSuperQuorum is Governor { function superQuorum(uint256 timepoint) public view virtual returns (uint256); function proposalVotes( uint256 proposalId ) public view virtual returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes); function state(uint256 proposalId) public view virtual override returns (ProposalState) { ProposalState currentState = super.state(proposalId); if (currentState != ProposalState.Active) return currentState; (, uint256 forVotes, ) = proposalVotes(proposalId); if (forVotes < superQuorum(proposalSnapshot(proposalId)) || !_voteSucceeded(proposalId)) { return ProposalState.Active; } else if (proposalEta(proposalId) == 0) { return ProposalState.Succeeded; } else { return ProposalState.Queued; } } } ", " pragma solidity >=0.8.4; import {IVotes} from \"../governance/utils/IVotes.sol\"; import {IERC6372} from \"./IERC6372.sol\"; interface IERC5805 is IERC6372, IVotes {} ", " pragma solidity ^0.8.20; import {Context} from \"../utils/Context.sol\"; abstract contract ERC2771Context is Context { address private immutable _trustedForwarder; constructor(address trustedForwarder_) { _trustedForwarder = trustedForwarder_; } function trustedForwarder() public view virtual returns (address) { return _trustedForwarder; } function isTrustedForwarder(address forwarder) public view virtual returns (bool) { return forwarder == trustedForwarder(); } function _msgSender() internal view virtual override returns (address) { uint256 calldataLength = msg.data.length; uint256 contextSuffixLength = _contextSuffixLength(); if (calldataLength >= contextSuffixLength && isTrustedForwarder(msg.sender)) { unchecked { return address(bytes20(msg.data[calldataLength - contextSuffixLength:])); } } else { return super._msgSender(); } } function _msgData() internal view virtual override returns (bytes calldata) { uint256 calldataLength = msg.data.length; uint256 contextSuffixLength = _contextSuffixLength(); if (calldataLength >= contextSuffixLength && isTrustedForwarder(msg.sender)) { unchecked { return msg.data[:calldataLength - contextSuffixLength]; } } else { return super._msgData(); } } function _contextSuffixLength() internal view virtual override returns (uint256) { return 20; } } ", " pragma solidity ^0.8.20; import {IEntryPoint, PackedUserOperation} from \"../../interfaces/draft-IERC4337.sol\"; import {Math} from \"../../utils/math/Math.sol\"; import {Calldata} from \"../../utils/Calldata.sol\"; import {Packing} from \"../../utils/Packing.sol\"; interface IEntryPointExtra { function getUserOpHash(PackedUserOperation calldata userOp) external view returns (bytes32); } library ERC4337Utils { using Packing for *; IEntryPoint internal constant ENTRYPOINT_V07 = IEntryPoint(0x0000000071727De22E5E9d8BAf0edAc6f37da032); IEntryPoint internal constant ENTRYPOINT_V08 = IEntryPoint(0x4337084D9E255Ff0702461CF8895CE9E3b5Ff108); uint256 internal constant SIG_VALIDATION_SUCCESS = 0; uint256 internal constant SIG_VALIDATION_FAILED = 1; function parseValidationData( uint256 validationData ) internal pure returns (address aggregator, uint48 validAfter, uint48 validUntil) { validAfter = uint48(bytes32(validationData).extract_32_6(0)); validUntil = uint48(bytes32(validationData).extract_32_6(6)); aggregator = address(bytes32(validationData).extract_32_20(12)); if (validUntil == 0) validUntil = type(uint48).max; } function packValidationData( address aggregator, uint48 validAfter, uint48 validUntil ) internal pure returns (uint256) { return uint256(bytes6(validAfter).pack_6_6(bytes6(validUntil)).pack_12_20(bytes20(aggregator))); } function packValidationData(bool sigSuccess, uint48 validAfter, uint48 validUntil) internal pure returns (uint256) { return packValidationData( address(uint160(Math.ternary(sigSuccess, SIG_VALIDATION_SUCCESS, SIG_VALIDATION_FAILED))), validAfter, validUntil ); } function combineValidationData(uint256 validationData1, uint256 validationData2) internal pure returns (uint256) { (address aggregator1, uint48 validAfter1, uint48 validUntil1) = parseValidationData(validationData1); (address aggregator2, uint48 validAfter2, uint48 validUntil2) = parseValidationData(validationData2); bool success = aggregator1 == address(uint160(SIG_VALIDATION_SUCCESS)) && aggregator2 == address(uint160(SIG_VALIDATION_SUCCESS)); uint48 validAfter = uint48(Math.max(validAfter1, validAfter2)); uint48 validUntil = uint48(Math.min(validUntil1, validUntil2)); return packValidationData(success, validAfter, validUntil); } function getValidationData(uint256 validationData) internal view returns (address aggregator, bool outOfTimeRange) { (address aggregator_, uint48 validAfter, uint48 validUntil) = parseValidationData(validationData); return (aggregator_, block.timestamp < validAfter || validUntil < block.timestamp); } function hash(PackedUserOperation calldata self, address entrypoint) internal view returns (bytes32) { return IEntryPointExtra(entrypoint).getUserOpHash(self); } function factory(PackedUserOperation calldata self) internal pure returns (address) { return self.initCode.length < 20 ? address(0) : address(bytes20(self.initCode[0:20])); } function factoryData(PackedUserOperation calldata self) internal pure returns (bytes calldata) { return self.initCode.length < 20 ? Calldata.emptyBytes() : self.initCode[20:]; } function verificationGasLimit(PackedUserOperation calldata self) internal pure returns (uint256) { return uint128(self.accountGasLimits.extract_32_16(0)); } function callGasLimit(PackedUserOperation calldata self) internal pure returns (uint256) { return uint128(self.accountGasLimits.extract_32_16(16)); } function maxPriorityFeePerGas(PackedUserOperation calldata self) internal pure returns (uint256) { return uint128(self.gasFees.extract_32_16(0)); } function maxFeePerGas(PackedUserOperation calldata self) internal pure returns (uint256) { return uint128(self.gasFees.extract_32_16(16)); } function gasPrice(PackedUserOperation calldata self) internal view returns (uint256) { unchecked { uint256 maxPriorityFee = maxPriorityFeePerGas(self); uint256 maxFee = maxFeePerGas(self); return Math.min(maxFee, maxPriorityFee + block.basefee); } } function paymaster(PackedUserOperation calldata self) internal pure returns (address) { return self.paymasterAndData.length < 52 ? address(0) : address(bytes20(self.paymasterAndData[0:20])); } function paymasterVerificationGasLimit(PackedUserOperation calldata self) internal pure returns (uint256) { return self.paymasterAndData.length < 52 ? 0 : uint128(bytes16(self.paymasterAndData[20:36])); } function paymasterPostOpGasLimit(PackedUserOperation calldata self) internal pure returns (uint256) { return self.paymasterAndData.length < 52 ? 0 : uint128(bytes16(self.paymasterAndData[36:52])); } function paymasterData(PackedUserOperation calldata self) internal pure returns (bytes calldata) { return self.paymasterAndData.length < 52 ? Calldata.emptyBytes() : self.paymasterAndData[52:]; } } ", " pragma solidity >=0.6.2; import {IERC20} from \"./IERC20.sol\"; interface IERC7674 is IERC20 { function temporaryApprove(address spender, uint256 value) external returns (bool success); } ", " pragma solidity >=0.6.2; import {IERC165} from \"../utils/introspection/IERC165.sol\"; interface IERC6909 is IERC165 { event Approval(address indexed owner, address indexed spender, uint256 indexed id, uint256 amount); event OperatorSet(address indexed owner, address indexed spender, bool approved); event Transfer( address caller, address indexed sender, address indexed receiver, uint256 indexed id, uint256 amount ); function balanceOf(address owner, uint256 id) external view returns (uint256); function allowance(address owner, address spender, uint256 id) external view returns (uint256); function isOperator(address owner, address spender) external view returns (bool); function approve(address spender, uint256 id, uint256 amount) external returns (bool); function setOperator(address spender, bool approved) external returns (bool); function transfer(address receiver, uint256 id, uint256 amount) external returns (bool); function transferFrom(address sender, address receiver, uint256 id, uint256 amount) external returns (bool); } interface IERC6909Metadata is IERC6909 { function name(uint256 id) external view returns (string memory); function symbol(uint256 id) external view returns (string memory); function decimals(uint256 id) external view returns (uint8); } interface IERC6909ContentURI is IERC6909 { function contractURI() external view returns (string memory); function tokenURI(uint256 id) external view returns (string memory); } interface IERC6909TokenSupply is IERC6909 { function totalSupply(uint256 id) external view returns (uint256); } ", " pragma solidity ^0.8.20; import {IERC20} from \"../token/ERC20/IERC20.sol\"; import {SafeERC20} from \"../token/ERC20/utils/SafeERC20.sol\"; import {Address} from \"../utils/Address.sol\"; import {Context} from \"../utils/Context.sol\"; import {Ownable} from \"../access/Ownable.sol\"; contract VestingWallet is Context, Ownable { event EtherReleased(uint256 amount); event ERC20Released(address indexed token, uint256 amount); uint256 private _released; mapping(address token => uint256) private _erc20Released; uint64 private immutable _start; uint64 private immutable _duration; constructor(address beneficiary, uint64 startTimestamp, uint64 durationSeconds) payable Ownable(beneficiary) { _start = startTimestamp; _duration = durationSeconds; } receive() external payable virtual {} function start() public view virtual returns (uint256) { return _start; } function duration() public view virtual returns (uint256) { return _duration; } function end() public view virtual returns (uint256) { return start() + duration(); } function released() public view virtual returns (uint256) { return _released; } function released(address token) public view virtual returns (uint256) { return _erc20Released[token]; } function releasable() public view virtual returns (uint256) { return vestedAmount(uint64(block.timestamp)) - released(); } function releasable(address token) public view virtual returns (uint256) { return vestedAmount(token, uint64(block.timestamp)) - released(token); } function release() public virtual { uint256 amount = releasable(); _released += amount; emit EtherReleased(amount); Address.sendValue(payable(owner()), amount); } function release(address token) public virtual { uint256 amount = releasable(token); _erc20Released[token] += amount; emit ERC20Released(token, amount); SafeERC20.safeTransfer(IERC20(token), owner(), amount); } function vestedAmount(uint64 timestamp) public view virtual returns (uint256) { return _vestingSchedule(address(this).balance + released(), timestamp); } function vestedAmount(address token, uint64 timestamp) public view virtual returns (uint256) { return _vestingSchedule(IERC20(token).balanceOf(address(this)) + released(token), timestamp); } function _vestingSchedule(uint256 totalAllocation, uint64 timestamp) internal view virtual returns (uint256) { if (timestamp < start()) { return 0; } else if (timestamp >= end()) { return totalAllocation; } else { return (totalAllocation * (timestamp - start())) / duration(); } } } ", " pragma solidity >=0.6.2; import {IERC20Permit} from \"../token/ERC20/extensions/IERC20Permit.sol\"; interface IERC2612 is IERC20Permit {} ", " pragma solidity >=0.4.16; interface IERC1822Proxiable { function proxiableUUID() external view returns (bytes32); } ", " pragma solidity >=0.5.0; interface IERC777Sender { function tokensToSend( address operator, address from, address to, uint256 amount, bytes calldata userData, bytes calldata operatorData ) external; } ", " pragma solidity >=0.6.2; import {IERC1155Receiver} from \"../token/ERC1155/IERC1155Receiver.sol\"; ", " pragma solidity >=0.8.4; import {IAccessControl} from \"../IAccessControl.sol\"; interface IAccessControlEnumerable is IAccessControl { function getRoleMember(bytes32 role, uint256 index) external view returns (address); function getRoleMemberCount(bytes32 role) external view returns (uint256); } ", " pragma solidity >=0.5.0; import {IERC721Receiver} from \"../token/ERC721/IERC721Receiver.sol\"; ", " pragma solidity ^0.8.24; import {IAccessControlEnumerable} from \"./IAccessControlEnumerable.sol\"; import {AccessControl} from \"../AccessControl.sol\"; import {EnumerableSet} from \"../../utils/structs/EnumerableSet.sol\"; import {IERC165} from \"../../utils/introspection/ERC165.sol\"; abstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl { using EnumerableSet for EnumerableSet.AddressSet; mapping(bytes32 role => EnumerableSet.AddressSet) private _roleMembers; function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId); } function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) { return _roleMembers[role].at(index); } function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) { return _roleMembers[role].length(); } function getRoleMembers(bytes32 role) public view virtual returns (address[] memory) { return _roleMembers[role].values(); } function _grantRole(bytes32 role, address account) internal virtual override returns (bool) { bool granted = super._grantRole(role, account); if (granted) { _roleMembers[role].add(account); } return granted; } function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) { bool revoked = super._revokeRole(role, account); if (revoked) { _roleMembers[role].remove(account); } return revoked; } } ", " pragma solidity >=0.6.2; import {IERC165} from \"../utils/introspection/IERC165.sol\"; interface IERC2981 is IERC165 { function royaltyInfo( uint256 tokenId, uint256 salePrice ) external view returns (address receiver, uint256 royaltyAmount); } ", " pragma solidity ^0.8.24; import {Governor} from \"../Governor.sol\"; abstract contract GovernorStorage is Governor { struct ProposalDetails { address[] targets; uint256[] values; bytes[] calldatas; bytes32 descriptionHash; } uint256[] private _proposalIds; mapping(uint256 proposalId => ProposalDetails) private _proposalDetails; function _propose( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, string memory description, address proposer ) internal virtual override returns (uint256) { uint256 proposalId = super._propose(targets, values, calldatas, description, proposer); _proposalIds.push(proposalId); _proposalDetails[proposalId] = ProposalDetails({ targets: targets, values: values, calldatas: calldatas, descriptionHash: keccak256(bytes(description)) }); return proposalId; } function queue(uint256 proposalId) public virtual { ProposalDetails storage details = _proposalDetails[proposalId]; queue(details.targets, details.values, details.calldatas, details.descriptionHash); } function execute(uint256 proposalId) public payable virtual { ProposalDetails storage details = _proposalDetails[proposalId]; execute(details.targets, details.values, details.calldatas, details.descriptionHash); } function cancel(uint256 proposalId) public virtual { ProposalDetails storage details = _proposalDetails[proposalId]; cancel(details.targets, details.values, details.calldatas, details.descriptionHash); } function proposalCount() public view virtual returns (uint256) { return _proposalIds.length; } function proposalDetails( uint256 proposalId ) public view virtual returns (address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash) { ProposalDetails memory details = _proposalDetails[proposalId]; if (details.descriptionHash == 0) { revert GovernorNonexistentProposal(proposalId); } return (details.targets, details.values, details.calldatas, details.descriptionHash); } function proposalDetailsAt( uint256 index ) public view virtual returns ( uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) { proposalId = _proposalIds[index]; (targets, values, calldatas, descriptionHash) = proposalDetails(proposalId); } } ", " pragma solidity ^0.8.24; import {IGovernor, Governor} from \"../Governor.sol\"; abstract contract GovernorCountingSimple is Governor { enum VoteType { Against, For, Abstain } struct ProposalVote { uint256 againstVotes; uint256 forVotes; uint256 abstainVotes; mapping(address voter => bool) hasVoted; } mapping(uint256 proposalId => ProposalVote) private _proposalVotes; function COUNTING_MODE() public pure virtual override returns (string memory) { return \"support=bravo&quorum=for,abstain\"; } function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) { return _proposalVotes[proposalId].hasVoted[account]; } function proposalVotes( uint256 proposalId ) public view virtual returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes) { ProposalVote storage proposalVote = _proposalVotes[proposalId]; return (proposalVote.againstVotes, proposalVote.forVotes, proposalVote.abstainVotes); } function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) { ProposalVote storage proposalVote = _proposalVotes[proposalId]; return quorum(proposalSnapshot(proposalId)) <= proposalVote.forVotes + proposalVote.abstainVotes; } function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) { ProposalVote storage proposalVote = _proposalVotes[proposalId]; return proposalVote.forVotes > proposalVote.againstVotes; } function _countVote( uint256 proposalId, address account, uint8 support, uint256 totalWeight, bytes memory ) internal virtual override returns (uint256) { ProposalVote storage proposalVote = _proposalVotes[proposalId]; if (proposalVote.hasVoted[account]) { revert GovernorAlreadyCastVote(account); } proposalVote.hasVoted[account] = true; if (support == uint8(VoteType.Against)) { proposalVote.againstVotes += totalWeight; } else if (support == uint8(VoteType.For)) { proposalVote.forVotes += totalWeight; } else if (support == uint8(VoteType.Abstain)) { proposalVote.abstainVotes += totalWeight; } else { revert GovernorInvalidVoteType(); } return totalWeight; } } ", " pragma solidity >=0.5.0; interface IERC3156FlashBorrower { function onFlashLoan( address initiator, address token, uint256 amount, uint256 fee, bytes calldata data ) external returns (bytes32); } ", " pragma solidity ^0.8.20; import {PackedUserOperation, IAccount, IEntryPoint} from \"../interfaces/draft-IERC4337.sol\"; import {ERC4337Utils} from \"./utils/draft-ERC4337Utils.sol\"; import {AbstractSigner} from \"../utils/cryptography/signers/AbstractSigner.sol\"; import {LowLevelCall} from \"../utils/LowLevelCall.sol\"; abstract contract Account is AbstractSigner, IAccount { error AccountUnauthorized(address sender); modifier onlyEntryPointOrSelf() { _checkEntryPointOrSelf(); _; } modifier onlyEntryPoint() { _checkEntryPoint(); _; } function entryPoint() public view virtual returns (IEntryPoint) { return ERC4337Utils.ENTRYPOINT_V08; } function getNonce() public view virtual returns (uint256) { return getNonce(0); } function getNonce(uint192 key) public view virtual returns (uint256) { return entryPoint().getNonce(address(this), key); } function validateUserOp( PackedUserOperation calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds ) public virtual onlyEntryPoint returns (uint256) { uint256 validationData = _validateUserOp(userOp, userOpHash, userOp.signature); _payPrefund(missingAccountFunds); return validationData; } function _validateUserOp( PackedUserOperation calldata userOp, bytes32 userOpHash, bytes calldata signature ) internal virtual returns (uint256) { return _rawSignatureValidation(_signableUserOpHash(userOp, userOpHash), signature) ? ERC4337Utils.SIG_VALIDATION_SUCCESS : ERC4337Utils.SIG_VALIDATION_FAILED; } function _signableUserOpHash( PackedUserOperation calldata , bytes32 userOpHash ) internal view virtual returns (bytes32) { return userOpHash; } function _payPrefund(uint256 missingAccountFunds) internal virtual { if (missingAccountFunds > 0) { LowLevelCall.callNoReturn(msg.sender, missingAccountFunds, \"\"); } } function _checkEntryPoint() internal view virtual { address sender = msg.sender; if (sender != address(entryPoint())) { revert AccountUnauthorized(sender); } } function _checkEntryPointOrSelf() internal view virtual { address sender = msg.sender; if (sender != address(this) && sender != address(entryPoint())) { revert AccountUnauthorized(sender); } } receive() external payable virtual {} } ", " pragma solidity >=0.5.0; interface IERC1820Registry { event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer); event ManagerChanged(address indexed account, address indexed newManager); function setManager(address account, address newManager) external; function getManager(address account) external view returns (address); function setInterfaceImplementer(address account, bytes32 _interfaceHash, address implementer) external; function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address); function interfaceHash(string calldata interfaceName) external pure returns (bytes32); function updateERC165Cache(address account, bytes4 interfaceId) external; function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool); function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool); } ", " pragma solidity ^0.8.20; import {Context} from \"../utils/Context.sol\"; abstract contract Ownable is Context { address private _owner; error OwnableUnauthorizedAccount(address account); error OwnableInvalidOwner(address owner); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor(address initialOwner) { if (initialOwner == address(0)) { revert OwnableInvalidOwner(address(0)); } _transferOwnership(initialOwner); } modifier onlyOwner() { _checkOwner(); _; } function owner() public view virtual returns (address) { return _owner; } function _checkOwner() internal view virtual { if (owner() != _msgSender()) { revert OwnableUnauthorizedAccount(_msgSender()); } } function renounceOwnership() public virtual onlyOwner { _transferOwnership(address(0)); } function transferOwnership(address newOwner) public virtual onlyOwner { if (newOwner == address(0)) { revert OwnableInvalidOwner(address(0)); } _transferOwnership(newOwner); } function _transferOwnership(address newOwner) internal virtual { address oldOwner = _owner; _owner = newOwner; emit OwnershipTransferred(oldOwner, newOwner); } } ", " pragma solidity ^0.8.24; import {IERC721Receiver} from \"../token/ERC721/IERC721Receiver.sol\"; import {IERC1155Receiver} from \"../token/ERC1155/IERC1155Receiver.sol\"; import {EIP712} from \"../utils/cryptography/EIP712.sol\"; import {SignatureChecker} from \"../utils/cryptography/SignatureChecker.sol\"; import {IERC165, ERC165} from \"../utils/introspection/ERC165.sol\"; import {SafeCast} from \"../utils/math/SafeCast.sol\"; import {DoubleEndedQueue} from \"../utils/structs/DoubleEndedQueue.sol\"; import {Address} from \"../utils/Address.sol\"; import {Context} from \"../utils/Context.sol\"; import {Nonces} from \"../utils/Nonces.sol\"; import {Strings} from \"../utils/Strings.sol\"; import {IGovernor, IERC6372} from \"./IGovernor.sol\"; abstract contract Governor is Context, ERC165, EIP712, Nonces, IGovernor, IERC721Receiver, IERC1155Receiver { using DoubleEndedQueue for DoubleEndedQueue.Bytes32Deque; bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,uint8 support,address voter,uint256 nonce)\"); bytes32 public constant EXTENDED_BALLOT_TYPEHASH = keccak256( \"ExtendedBallot(uint256 proposalId,uint8 support,address voter,uint256 nonce,string reason,bytes params)\" ); struct ProposalCore { address proposer; uint48 voteStart; uint32 voteDuration; bool executed; bool canceled; uint48 etaSeconds; } bytes32 private constant ALL_PROPOSAL_STATES_BITMAP = bytes32((2 ** (uint8(type(ProposalState).max) + 1)) - 1); string private _name; mapping(uint256 proposalId => ProposalCore) private _proposals; DoubleEndedQueue.Bytes32Deque private _governanceCall; modifier onlyGovernance() { _checkGovernance(); _; } constructor(string memory name_) EIP712(name_, version()) { _name = name_; } receive() external payable virtual { if (_executor() != address(this)) { revert GovernorDisabledDeposit(); } } function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) { return interfaceId == type(IGovernor).interfaceId || interfaceId == type(IGovernor).interfaceId ^ IGovernor.getProposalId.selector || interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId); } function name() public view virtual returns (string memory) { return _name; } function version() public view virtual returns (string memory) { return \"1\"; } function hashProposal( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) public pure virtual returns (uint256) { return uint256(keccak256(abi.encode(targets, values, calldatas, descriptionHash))); } function getProposalId( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) public view virtual returns (uint256) { return hashProposal(targets, values, calldatas, descriptionHash); } function state(uint256 proposalId) public view virtual returns (ProposalState) { ProposalCore storage proposal = _proposals[proposalId]; bool proposalExecuted = proposal.executed; bool proposalCanceled = proposal.canceled; if (proposalExecuted) { return ProposalState.Executed; } if (proposalCanceled) { return ProposalState.Canceled; } uint256 snapshot = proposalSnapshot(proposalId); if (snapshot == 0) { revert GovernorNonexistentProposal(proposalId); } uint256 currentTimepoint = clock(); if (snapshot >= currentTimepoint) { return ProposalState.Pending; } uint256 deadline = proposalDeadline(proposalId); if (deadline >= currentTimepoint) { return ProposalState.Active; } else if (!_quorumReached(proposalId) || !_voteSucceeded(proposalId)) { return ProposalState.Defeated; } else if (proposalEta(proposalId) == 0) { return ProposalState.Succeeded; } else { return ProposalState.Queued; } } function proposalThreshold() public view virtual returns (uint256) { return 0; } function proposalSnapshot(uint256 proposalId) public view virtual returns (uint256) { return _proposals[proposalId].voteStart; } function proposalDeadline(uint256 proposalId) public view virtual returns (uint256) { return _proposals[proposalId].voteStart + _proposals[proposalId].voteDuration; } function proposalProposer(uint256 proposalId) public view virtual returns (address) { return _proposals[proposalId].proposer; } function proposalEta(uint256 proposalId) public view virtual returns (uint256) { return _proposals[proposalId].etaSeconds; } function proposalNeedsQueuing(uint256) public view virtual returns (bool) { return false; } function _checkGovernance() internal virtual { if (_executor() != _msgSender()) { revert GovernorOnlyExecutor(_msgSender()); } if (_executor() != address(this)) { bytes32 msgDataHash = keccak256(_msgData()); while (_governanceCall.popFront() != msgDataHash) {} } } function _quorumReached(uint256 proposalId) internal view virtual returns (bool); function _voteSucceeded(uint256 proposalId) internal view virtual returns (bool); function _getVotes(address account, uint256 timepoint, bytes memory params) internal view virtual returns (uint256); function _countVote( uint256 proposalId, address account, uint8 support, uint256 totalWeight, bytes memory params ) internal virtual returns (uint256); function _tallyUpdated(uint256 proposalId) internal virtual {} function _defaultParams() internal view virtual returns (bytes memory) { return \"\"; } function propose( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, string memory description ) public virtual returns (uint256) { address proposer = _msgSender(); if (!_isValidDescriptionForProposer(proposer, description)) { revert GovernorRestrictedProposer(proposer); } uint256 votesThreshold = proposalThreshold(); if (votesThreshold > 0) { uint256 proposerVotes = getVotes(proposer, clock() - 1); if (proposerVotes < votesThreshold) { revert GovernorInsufficientProposerVotes(proposer, proposerVotes, votesThreshold); } } return _propose(targets, values, calldatas, description, proposer); } function _propose( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, string memory description, address proposer ) internal virtual returns (uint256 proposalId) { proposalId = getProposalId(targets, values, calldatas, keccak256(bytes(description))); if (targets.length != values.length || targets.length != calldatas.length || targets.length == 0) { revert GovernorInvalidProposalLength(targets.length, calldatas.length, values.length); } if (_proposals[proposalId].voteStart != 0) { revert GovernorUnexpectedProposalState(proposalId, state(proposalId), bytes32(0)); } uint256 snapshot = clock() + votingDelay(); uint256 duration = votingPeriod(); ProposalCore storage proposal = _proposals[proposalId]; proposal.proposer = proposer; proposal.voteStart = SafeCast.toUint48(snapshot); proposal.voteDuration = SafeCast.toUint32(duration); emit ProposalCreated( proposalId, proposer, targets, values, new string[](targets.length), calldatas, snapshot, snapshot + duration, description ); } function queue( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) public virtual returns (uint256) { uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash); _validateStateBitmap(proposalId, _encodeStateBitmap(ProposalState.Succeeded)); uint48 etaSeconds = _queueOperations(proposalId, targets, values, calldatas, descriptionHash); if (etaSeconds != 0) { _proposals[proposalId].etaSeconds = etaSeconds; emit ProposalQueued(proposalId, etaSeconds); } else { revert GovernorQueueNotImplemented(); } return proposalId; } function _queueOperations( uint256 , address[] memory , uint256[] memory , bytes[] memory , bytes32 ) internal virtual returns (uint48) { return 0; } function execute( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) public payable virtual returns (uint256) { uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash); _validateStateBitmap( proposalId, _encodeStateBitmap(ProposalState.Succeeded) | _encodeStateBitmap(ProposalState.Queued) ); _proposals[proposalId].executed = true; if (_executor() != address(this)) { for (uint256 i = 0; i < targets.length; ++i) { if (targets[i] == address(this)) { _governanceCall.pushBack(keccak256(calldatas[i])); } } } _executeOperations(proposalId, targets, values, calldatas, descriptionHash); if (_executor() != address(this) && !_governanceCall.empty()) { _governanceCall.clear(); } emit ProposalExecuted(proposalId); return proposalId; } function _executeOperations( uint256 , address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 ) internal virtual { for (uint256 i = 0; i < targets.length; ++i) { (bool success, bytes memory returndata) = targets[i].call{value: values[i]}(calldatas[i]); Address.verifyCallResult(success, returndata); } } function cancel( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) public virtual returns (uint256) { uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash); address caller = _msgSender(); if (!_validateCancel(proposalId, caller)) revert GovernorUnableToCancel(proposalId, caller); return _cancel(targets, values, calldatas, descriptionHash); } function _cancel( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) internal virtual returns (uint256) { uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash); _validateStateBitmap( proposalId, ALL_PROPOSAL_STATES_BITMAP ^ _encodeStateBitmap(ProposalState.Canceled) ^ _encodeStateBitmap(ProposalState.Expired) ^ _encodeStateBitmap(ProposalState.Executed) ); _proposals[proposalId].canceled = true; emit ProposalCanceled(proposalId); return proposalId; } function getVotes(address account, uint256 timepoint) public view virtual returns (uint256) { return _getVotes(account, timepoint, _defaultParams()); } function getVotesWithParams( address account, uint256 timepoint, bytes memory params ) public view virtual returns (uint256) { return _getVotes(account, timepoint, params); } function castVote(uint256 proposalId, uint8 support) public virtual returns (uint256) { address voter = _msgSender(); return _castVote(proposalId, voter, support, \"\"); } function castVoteWithReason( uint256 proposalId, uint8 support, string calldata reason ) public virtual returns (uint256) { address voter = _msgSender(); return _castVote(proposalId, voter, support, reason); } function castVoteWithReasonAndParams( uint256 proposalId, uint8 support, string calldata reason, bytes memory params ) public virtual returns (uint256) { address voter = _msgSender(); return _castVote(proposalId, voter, support, reason, params); } function castVoteBySig( uint256 proposalId, uint8 support, address voter, bytes memory signature ) public virtual returns (uint256) { if (!_validateVoteSig(proposalId, support, voter, signature)) { revert GovernorInvalidSignature(voter); } return _castVote(proposalId, voter, support, \"\"); } function castVoteWithReasonAndParamsBySig( uint256 proposalId, uint8 support, address voter, string calldata reason, bytes memory params, bytes memory signature ) public virtual returns (uint256) { if (!_validateExtendedVoteSig(proposalId, support, voter, reason, params, signature)) { revert GovernorInvalidSignature(voter); } return _castVote(proposalId, voter, support, reason, params); } function _validateVoteSig( uint256 proposalId, uint8 support, address voter, bytes memory signature ) internal virtual returns (bool) { return SignatureChecker.isValidSignatureNow( voter, _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support, voter, _useNonce(voter)))), signature ); } function _validateExtendedVoteSig( uint256 proposalId, uint8 support, address voter, string memory reason, bytes memory params, bytes memory signature ) internal virtual returns (bool) { return SignatureChecker.isValidSignatureNow( voter, _hashTypedDataV4( keccak256( abi.encode( EXTENDED_BALLOT_TYPEHASH, proposalId, support, voter, _useNonce(voter), keccak256(bytes(reason)), keccak256(params) ) ) ), signature ); } function _castVote( uint256 proposalId, address account, uint8 support, string memory reason ) internal virtual returns (uint256) { return _castVote(proposalId, account, support, reason, _defaultParams()); } function _castVote( uint256 proposalId, address account, uint8 support, string memory reason, bytes memory params ) internal virtual returns (uint256) { _validateStateBitmap(proposalId, _encodeStateBitmap(ProposalState.Active)); uint256 totalWeight = _getVotes(account, proposalSnapshot(proposalId), params); uint256 votedWeight = _countVote(proposalId, account, support, totalWeight, params); if (params.length == 0) { emit VoteCast(account, proposalId, support, votedWeight, reason); } else { emit VoteCastWithParams(account, proposalId, support, votedWeight, reason, params); } _tallyUpdated(proposalId); return votedWeight; } function relay(address target, uint256 value, bytes calldata data) public payable virtual onlyGovernance { (bool success, bytes memory returndata) = target.call{value: value}(data); Address.verifyCallResult(success, returndata); } function _executor() internal view virtual returns (address) { return address(this); } function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) { if (_executor() != address(this)) { revert GovernorDisabledDeposit(); } return this.onERC721Received.selector; } function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual returns (bytes4) { if (_executor() != address(this)) { revert GovernorDisabledDeposit(); } return this.onERC1155Received.selector; } function onERC1155BatchReceived( address, address, uint256[] memory, uint256[] memory, bytes memory ) public virtual returns (bytes4) { if (_executor() != address(this)) { revert GovernorDisabledDeposit(); } return this.onERC1155BatchReceived.selector; } function _encodeStateBitmap(ProposalState proposalState) internal pure returns (bytes32) { return bytes32(1 << uint8(proposalState)); } function _validateStateBitmap(uint256 proposalId, bytes32 allowedStates) internal view returns (ProposalState) { ProposalState currentState = state(proposalId); if (_encodeStateBitmap(currentState) & allowedStates == bytes32(0)) { revert GovernorUnexpectedProposalState(proposalId, currentState, allowedStates); } return currentState; } function _isValidDescriptionForProposer( address proposer, string memory description ) internal view virtual returns (bool) { unchecked { uint256 length = bytes(description).length; if (length < 52) { return true; } bytes10 marker = bytes10(_unsafeReadBytesOffset(bytes(description), length - 52)); if (marker != bytes10(\"#proposer=\")) { return true; } (bool success, address recovered) = Strings.tryParseAddress(description, length - 42, length); return !success || recovered == proposer; } } function _validateCancel(uint256 proposalId, address caller) internal view virtual returns (bool) { return (state(proposalId) == ProposalState.Pending) && caller == proposalProposer(proposalId); } function clock() public view virtual returns (uint48); function CLOCK_MODE() public view virtual returns (string memory); function votingDelay() public view virtual returns (uint256); function votingPeriod() public view virtual returns (uint256); function quorum(uint256 timepoint) public view virtual returns (uint256); function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) { assembly (\"memory-safe\") { value := mload(add(add(buffer, 0x20), offset)) } } } ", " pragma solidity >=0.5.0; interface IERC1363Spender { function onApprovalReceived(address owner, uint256 value, bytes calldata data) external returns (bytes4); } ", " pragma solidity >=0.6.2; import {IERC1155} from \"../token/ERC1155/IERC1155.sol\"; ", " pragma solidity ^0.8.24; import {Governor} from \"../Governor.sol\"; import {GovernorSuperQuorum} from \"./GovernorSuperQuorum.sol\"; import {GovernorVotesQuorumFraction} from \"./GovernorVotesQuorumFraction.sol\"; import {Math} from \"../../utils/math/Math.sol\"; import {SafeCast} from \"../../utils/math/SafeCast.sol\"; import {Checkpoints} from \"../../utils/structs/Checkpoints.sol\"; abstract contract GovernorVotesSuperQuorumFraction is GovernorVotesQuorumFraction, GovernorSuperQuorum { using Checkpoints for Checkpoints.Trace208; Checkpoints.Trace208 private _superQuorumNumeratorHistory; event SuperQuorumNumeratorUpdated(uint256 oldSuperQuorumNumerator, uint256 newSuperQuorumNumerator); error GovernorInvalidSuperQuorumFraction(uint256 superQuorumNumerator, uint256 denominator); error GovernorInvalidSuperQuorumTooSmall(uint256 superQuorumNumerator, uint256 quorumNumerator); error GovernorInvalidQuorumTooLarge(uint256 quorumNumerator, uint256 superQuorumNumerator); constructor(uint256 superQuorumNumeratorValue) { _updateSuperQuorumNumerator(superQuorumNumeratorValue); } function superQuorumNumerator() public view virtual returns (uint256) { return _superQuorumNumeratorHistory.latest(); } function superQuorumNumerator(uint256 timepoint) public view virtual returns (uint256) { return _optimisticUpperLookupRecent(_superQuorumNumeratorHistory, timepoint); } function superQuorum(uint256 timepoint) public view virtual override returns (uint256) { return Math.mulDiv(token().getPastTotalSupply(timepoint), superQuorumNumerator(timepoint), quorumDenominator()); } function updateSuperQuorumNumerator(uint256 newSuperQuorumNumerator) public virtual onlyGovernance { _updateSuperQuorumNumerator(newSuperQuorumNumerator); } function _updateSuperQuorumNumerator(uint256 newSuperQuorumNumerator) internal virtual { uint256 denominator = quorumDenominator(); if (newSuperQuorumNumerator > denominator) { revert GovernorInvalidSuperQuorumFraction(newSuperQuorumNumerator, denominator); } uint256 quorumNumerator = quorumNumerator(); if (newSuperQuorumNumerator < quorumNumerator) { revert GovernorInvalidSuperQuorumTooSmall(newSuperQuorumNumerator, quorumNumerator); } uint256 oldSuperQuorumNumerator = _superQuorumNumeratorHistory.latest(); _superQuorumNumeratorHistory.push(clock(), SafeCast.toUint208(newSuperQuorumNumerator)); emit SuperQuorumNumeratorUpdated(oldSuperQuorumNumerator, newSuperQuorumNumerator); } function _updateQuorumNumerator(uint256 newQuorumNumerator) internal virtual override { if (_superQuorumNumeratorHistory.length() > 0) { uint256 superQuorumNumerator_ = superQuorumNumerator(); if (newQuorumNumerator > superQuorumNumerator_) { revert GovernorInvalidQuorumTooLarge(newQuorumNumerator, superQuorumNumerator_); } } super._updateQuorumNumerator(newQuorumNumerator); } function state( uint256 proposalId ) public view virtual override(Governor, GovernorSuperQuorum) returns (ProposalState) { return super.state(proposalId); } } ", " pragma solidity ^0.8.26; import {PackedUserOperation} from \"../../interfaces/draft-IERC4337.sol\"; import {IERC1271} from \"../../interfaces/IERC1271.sol\"; import { IERC7579Module, IERC7579Validator, IERC7579Execution, IERC7579AccountConfig, IERC7579ModuleConfig, MODULE_TYPE_VALIDATOR, MODULE_TYPE_EXECUTOR, MODULE_TYPE_FALLBACK } from \"../../interfaces/draft-IERC7579.sol\"; import {ERC7579Utils, Mode, CallType, ExecType} from \"../../account/utils/draft-ERC7579Utils.sol\"; import {EnumerableSet} from \"../../utils/structs/EnumerableSet.sol\"; import {LowLevelCall} from \"../../utils/LowLevelCall.sol\"; import {Bytes} from \"../../utils/Bytes.sol\"; import {Packing} from \"../../utils/Packing.sol\"; import {Calldata} from \"../../utils/Calldata.sol\"; import {Account} from \"../Account.sol\"; abstract contract AccountERC7579 is Account, IERC1271, IERC7579Execution, IERC7579AccountConfig, IERC7579ModuleConfig { using Bytes for *; using ERC7579Utils for *; using EnumerableSet for *; using Packing for bytes32; EnumerableSet.AddressSet private _validators; EnumerableSet.AddressSet private _executors; mapping(bytes4 selector => address) private _fallbacks; error ERC7579MissingFallbackHandler(bytes4 selector); error ERC7579CannotDecodeFallbackData(); modifier onlyModule(uint256 moduleTypeId, bytes calldata additionalContext) { _checkModule(moduleTypeId, msg.sender, additionalContext); _; } fallback(bytes calldata) external payable virtual returns (bytes memory) { return _fallback(); } function accountId() public view virtual returns (string memory) { return \"@openzeppelin/community-contracts.AccountERC7579.v0.0.0\"; } function supportsExecutionMode(bytes32 encodedMode) public view virtual returns (bool) { (CallType callType, ExecType execType, , ) = Mode.wrap(encodedMode).decodeMode(); return (callType == ERC7579Utils.CALLTYPE_SINGLE || callType == ERC7579Utils.CALLTYPE_BATCH || callType == ERC7579Utils.CALLTYPE_DELEGATECALL) && (execType == ERC7579Utils.EXECTYPE_DEFAULT || execType == ERC7579Utils.EXECTYPE_TRY); } function supportsModule(uint256 moduleTypeId) public view virtual returns (bool) { return moduleTypeId == MODULE_TYPE_VALIDATOR || moduleTypeId == MODULE_TYPE_EXECUTOR || moduleTypeId == MODULE_TYPE_FALLBACK; } function installModule( uint256 moduleTypeId, address module, bytes calldata initData ) public virtual onlyEntryPointOrSelf { _installModule(moduleTypeId, module, initData); } function uninstallModule( uint256 moduleTypeId, address module, bytes calldata deInitData ) public virtual onlyEntryPointOrSelf { _uninstallModule(moduleTypeId, module, deInitData); } function isModuleInstalled( uint256 moduleTypeId, address module, bytes calldata additionalContext ) public view virtual returns (bool) { if (moduleTypeId == MODULE_TYPE_VALIDATOR) return _validators.contains(module); if (moduleTypeId == MODULE_TYPE_EXECUTOR) return _executors.contains(module); if (moduleTypeId == MODULE_TYPE_FALLBACK) return additionalContext.length > 3 && _fallbacks[bytes4(additionalContext[0:4])] == module; return false; } function execute(bytes32 mode, bytes calldata executionCalldata) public payable virtual onlyEntryPointOrSelf { _execute(Mode.wrap(mode), executionCalldata); } function executeFromExecutor( bytes32 mode, bytes calldata executionCalldata ) public payable virtual onlyModule(MODULE_TYPE_EXECUTOR, Calldata.emptyBytes()) returns (bytes[] memory returnData) { return _execute(Mode.wrap(mode), executionCalldata); } function isValidSignature(bytes32 hash, bytes calldata signature) public view virtual returns (bytes4) { if (signature.length >= 20) { (address module, bytes calldata innerSignature) = _extractSignatureValidator(signature); if (isModuleInstalled(MODULE_TYPE_VALIDATOR, module, Calldata.emptyBytes())) { try IERC7579Validator(module).isValidSignatureWithSender(msg.sender, hash, innerSignature) returns ( bytes4 magic ) { return magic; } catch {} } } return bytes4(0xffffffff); } function _validateUserOp( PackedUserOperation calldata userOp, bytes32 userOpHash, bytes calldata signature ) internal virtual override returns (uint256) { address module = _extractUserOpValidator(userOp); return isModuleInstalled(MODULE_TYPE_VALIDATOR, module, Calldata.emptyBytes()) ? IERC7579Validator(module).validateUserOp(userOp, _signableUserOpHash(userOp, userOpHash)) : super._validateUserOp(userOp, userOpHash, signature); } function _execute( Mode mode, bytes calldata executionCalldata ) internal virtual returns (bytes[] memory returnData) { (CallType callType, ExecType execType, , ) = mode.decodeMode(); if (callType == ERC7579Utils.CALLTYPE_SINGLE) return executionCalldata.execSingle(execType); if (callType == ERC7579Utils.CALLTYPE_BATCH) return executionCalldata.execBatch(execType); if (callType == ERC7579Utils.CALLTYPE_DELEGATECALL) return executionCalldata.execDelegateCall(execType); revert ERC7579Utils.ERC7579UnsupportedCallType(callType); } function _installModule(uint256 moduleTypeId, address module, bytes memory initData) internal virtual { require(supportsModule(moduleTypeId), ERC7579Utils.ERC7579UnsupportedModuleType(moduleTypeId)); require( IERC7579Module(module).isModuleType(moduleTypeId), ERC7579Utils.ERC7579MismatchedModuleTypeId(moduleTypeId, module) ); if (moduleTypeId == MODULE_TYPE_VALIDATOR) { require(_validators.add(module), ERC7579Utils.ERC7579AlreadyInstalledModule(moduleTypeId, module)); } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) { require(_executors.add(module), ERC7579Utils.ERC7579AlreadyInstalledModule(moduleTypeId, module)); } else if (moduleTypeId == MODULE_TYPE_FALLBACK) { bytes4 selector; (selector, initData) = _decodeFallbackData(initData); require( _fallbacks[selector] == address(0), ERC7579Utils.ERC7579AlreadyInstalledModule(moduleTypeId, module) ); _fallbacks[selector] = module; } IERC7579Module(module).onInstall(initData); emit ModuleInstalled(moduleTypeId, module); } function _uninstallModule(uint256 moduleTypeId, address module, bytes memory deInitData) internal virtual { require(supportsModule(moduleTypeId), ERC7579Utils.ERC7579UnsupportedModuleType(moduleTypeId)); if (moduleTypeId == MODULE_TYPE_VALIDATOR) { require(_validators.remove(module), ERC7579Utils.ERC7579UninstalledModule(moduleTypeId, module)); } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) { require(_executors.remove(module), ERC7579Utils.ERC7579UninstalledModule(moduleTypeId, module)); } else if (moduleTypeId == MODULE_TYPE_FALLBACK) { bytes4 selector; (selector, deInitData) = _decodeFallbackData(deInitData); require( _fallbackHandler(selector) == module && module != address(0), ERC7579Utils.ERC7579UninstalledModule(moduleTypeId, module) ); delete _fallbacks[selector]; } IERC7579Module(module).onUninstall(deInitData); emit ModuleUninstalled(moduleTypeId, module); } function _fallback() internal virtual returns (bytes memory) { address handler = _fallbackHandler(msg.sig); require(handler != address(0), ERC7579MissingFallbackHandler(msg.sig)); if (LowLevelCall.callNoReturn(handler, msg.value, abi.encodePacked(msg.data, msg.sender))) { return LowLevelCall.returnData(); } else { LowLevelCall.bubbleRevert(); } } function _fallbackHandler(bytes4 selector) internal view virtual returns (address) { return _fallbacks[selector]; } function _checkModule( uint256 moduleTypeId, address module, bytes calldata additionalContext ) internal view virtual { require( isModuleInstalled(moduleTypeId, module, additionalContext), ERC7579Utils.ERC7579UninstalledModule(moduleTypeId, module) ); } function _extractUserOpValidator(PackedUserOperation calldata userOp) internal pure virtual returns (address) { return address(bytes32(userOp.nonce).extract_32_20(0)); } function _extractSignatureValidator( bytes calldata signature ) internal pure virtual returns (address module, bytes calldata innerSignature) { return (address(bytes20(signature)), signature[20:]); } function _decodeFallbackData( bytes memory data ) internal pure virtual returns (bytes4 selector, bytes memory remaining) { require(data.length > 3, ERC7579CannotDecodeFallbackData()); return (bytes4(data), data.slice(4)); } function _rawSignatureValidation( bytes32 , bytes calldata ) internal view virtual override returns (bool) { return false; } } ", " pragma solidity >=0.8.4; interface IERC20Errors { error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed); error ERC20InvalidSender(address sender); error ERC20InvalidReceiver(address receiver); error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed); error ERC20InvalidApprover(address approver); error ERC20InvalidSpender(address spender); } interface IERC721Errors { error ERC721InvalidOwner(address owner); error ERC721NonexistentToken(uint256 tokenId); error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner); error ERC721InvalidSender(address sender); error ERC721InvalidReceiver(address receiver); error ERC721InsufficientApproval(address operator, uint256 tokenId); error ERC721InvalidApprover(address approver); error ERC721InvalidOperator(address operator); } interface IERC1155Errors { error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId); error ERC1155InvalidSender(address sender); error ERC1155InvalidReceiver(address receiver); error ERC1155MissingApprovalForAll(address operator, address owner); error ERC1155InvalidApprover(address approver); error ERC1155InvalidOperator(address operator); error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength); } ", " pragma solidity >=0.8.4; struct PackedUserOperation { address sender; uint256 nonce; bytes initCode; bytes callData; bytes32 accountGasLimits; uint256 preVerificationGas; bytes32 gasFees; bytes paymasterAndData; bytes signature; } interface IAggregator { function validateUserOpSignature( PackedUserOperation calldata userOp ) external view returns (bytes memory sigForUserOp); function aggregateSignatures( PackedUserOperation[] calldata userOps ) external view returns (bytes memory aggregatesSignature); function validateSignatures(PackedUserOperation[] calldata userOps, bytes calldata signature) external view; } interface IEntryPointNonces { function getNonce(address sender, uint192 key) external view returns (uint256 nonce); } interface IEntryPointStake { function balanceOf(address account) external view returns (uint256); function depositTo(address account) external payable; function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external; function addStake(uint32 unstakeDelaySec) external payable; function unlockStake() external; function withdrawStake(address payable withdrawAddress) external; } interface IEntryPoint is IEntryPointNonces, IEntryPointStake { error FailedOp(uint256 opIndex, string reason); error FailedOpWithRevert(uint256 opIndex, string reason, bytes inner); struct UserOpsPerAggregator { PackedUserOperation[] userOps; IAggregator aggregator; bytes signature; } function handleOps(PackedUserOperation[] calldata ops, address payable beneficiary) external; function handleAggregatedOps( UserOpsPerAggregator[] calldata opsPerAggregator, address payable beneficiary ) external; } interface IAccount { function validateUserOp( PackedUserOperation calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds ) external returns (uint256 validationData); } interface IAccountExecute { function executeUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash) external; } interface IPaymaster { enum PostOpMode { opSucceeded, opReverted, postOpReverted } function validatePaymasterUserOp( PackedUserOperation calldata userOp, bytes32 userOpHash, uint256 maxCost ) external returns (bytes memory context, uint256 validationData); function postOp( PostOpMode mode, bytes calldata context, uint256 actualGasCost, uint256 actualUserOpFeePerGas ) external; } ", " pragma solidity ^0.8.24; import {IGovernor, Governor} from \"../Governor.sol\"; import {TimelockController} from \"../TimelockController.sol\"; import {SafeCast} from \"../../utils/math/SafeCast.sol\"; abstract contract GovernorTimelockControl is Governor { TimelockController private _timelock; mapping(uint256 proposalId => bytes32) private _timelockIds; event TimelockChange(address oldTimelock, address newTimelock); constructor(TimelockController timelockAddress) { _updateTimelock(timelockAddress); } function state(uint256 proposalId) public view virtual override returns (ProposalState) { ProposalState currentState = super.state(proposalId); if (currentState != ProposalState.Queued) { return currentState; } bytes32 queueId = _timelockIds[proposalId]; if (_timelock.isOperationPending(queueId)) { return ProposalState.Queued; } else if (_timelock.isOperationDone(queueId)) { return ProposalState.Executed; } else { return ProposalState.Canceled; } } function timelock() public view virtual returns (address) { return address(_timelock); } function proposalNeedsQueuing(uint256) public view virtual override returns (bool) { return true; } function _queueOperations( uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) internal virtual override returns (uint48) { uint256 delay = _timelock.getMinDelay(); bytes32 salt = _timelockSalt(descriptionHash); _timelockIds[proposalId] = _timelock.hashOperationBatch(targets, values, calldatas, 0, salt); _timelock.scheduleBatch(targets, values, calldatas, 0, salt, delay); return SafeCast.toUint48(block.timestamp + delay); } function _executeOperations( uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) internal virtual override { _timelock.executeBatch{value: msg.value}(targets, values, calldatas, 0, _timelockSalt(descriptionHash)); delete _timelockIds[proposalId]; } function _cancel( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) internal virtual override returns (uint256) { uint256 proposalId = super._cancel(targets, values, calldatas, descriptionHash); bytes32 timelockId = _timelockIds[proposalId]; if (timelockId != 0) { _timelock.cancel(timelockId); delete _timelockIds[proposalId]; } return proposalId; } function _executor() internal view virtual override returns (address) { return address(_timelock); } function updateTimelock(TimelockController newTimelock) public virtual onlyGovernance { _updateTimelock(newTimelock); } function _updateTimelock(TimelockController newTimelock) private { emit TimelockChange(address(_timelock), address(newTimelock)); _timelock = newTimelock; } function _timelockSalt(bytes32 descriptionHash) private view returns (bytes32) { return bytes20(address(this)) ^ descriptionHash; } } ", " pragma solidity >=0.4.11; interface IERC1967 { event Upgraded(address indexed implementation); event AdminChanged(address previousAdmin, address newAdmin); event BeaconUpgraded(address indexed beacon); } ", " pragma solidity >=0.4.16; interface IERC1820Implementer { function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) external view returns (bytes32); } ", " pragma solidity >=0.5.0; interface IERC7821 { function execute(bytes32 mode, bytes calldata executionData) external payable; function supportsExecutionMode(bytes32 mode) external view returns (bool); } ", " pragma solidity >=0.5.0; import {IERC3156FlashBorrower} from \"./IERC3156FlashBorrower.sol\"; import {IERC3156FlashLender} from \"./IERC3156FlashLender.sol\"; ", " pragma solidity >=0.6.2; import {IERC721} from \"../token/ERC721/IERC721.sol\"; ", " pragma solidity >=0.5.0; interface IERC1363Receiver { function onTransferReceived( address operator, address from, uint256 value, bytes calldata data ) external returns (bytes4); } ", " pragma solidity >=0.5.0; interface IERC7913SignatureVerifier { function verify(bytes calldata key, bytes32 hash, bytes calldata signature) external view returns (bytes4); } ", " pragma solidity >=0.4.16; interface IERC6372 { function clock() external view returns (uint48); function CLOCK_MODE() external view returns (string memory); } ", " pragma solidity ^0.8.20; import {IAccessControlDefaultAdminRules} from \"./IAccessControlDefaultAdminRules.sol\"; import {AccessControl, IAccessControl} from \"../AccessControl.sol\"; import {SafeCast} from \"../../utils/math/SafeCast.sol\"; import {Math} from \"../../utils/math/Math.sol\"; import {IERC5313} from \"../../interfaces/IERC5313.sol\"; import {IERC165} from \"../../utils/introspection/IERC165.sol\"; abstract contract AccessControlDefaultAdminRules is IAccessControlDefaultAdminRules, IERC5313, AccessControl { address private _pendingDefaultAdmin; uint48 private _pendingDefaultAdminSchedule; uint48 private _currentDelay; address private _currentDefaultAdmin; uint48 private _pendingDelay; uint48 private _pendingDelaySchedule; constructor(uint48 initialDelay, address initialDefaultAdmin) { if (initialDefaultAdmin == address(0)) { revert AccessControlInvalidDefaultAdmin(address(0)); } _currentDelay = initialDelay; _grantRole(DEFAULT_ADMIN_ROLE, initialDefaultAdmin); } function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { return interfaceId == type(IAccessControlDefaultAdminRules).interfaceId || super.supportsInterface(interfaceId); } function owner() public view virtual returns (address) { return defaultAdmin(); } function grantRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) { if (role == DEFAULT_ADMIN_ROLE) { revert AccessControlEnforcedDefaultAdminRules(); } super.grantRole(role, account); } function revokeRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) { if (role == DEFAULT_ADMIN_ROLE) { revert AccessControlEnforcedDefaultAdminRules(); } super.revokeRole(role, account); } function renounceRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) { if (role == DEFAULT_ADMIN_ROLE && account == defaultAdmin()) { (address newDefaultAdmin, uint48 schedule) = pendingDefaultAdmin(); if (newDefaultAdmin != address(0) || !_isScheduleSet(schedule) || !_hasSchedulePassed(schedule)) { revert AccessControlEnforcedDefaultAdminDelay(schedule); } delete _pendingDefaultAdminSchedule; } super.renounceRole(role, account); } function _grantRole(bytes32 role, address account) internal virtual override returns (bool) { if (role == DEFAULT_ADMIN_ROLE) { if (defaultAdmin() != address(0)) { revert AccessControlEnforcedDefaultAdminRules(); } _currentDefaultAdmin = account; } return super._grantRole(role, account); } function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) { if (role == DEFAULT_ADMIN_ROLE && account == defaultAdmin()) { delete _currentDefaultAdmin; } return super._revokeRole(role, account); } function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual override { if (role == DEFAULT_ADMIN_ROLE) { revert AccessControlEnforcedDefaultAdminRules(); } super._setRoleAdmin(role, adminRole); } function defaultAdmin() public view virtual returns (address) { return _currentDefaultAdmin; } function pendingDefaultAdmin() public view virtual returns (address newAdmin, uint48 schedule) { return (_pendingDefaultAdmin, _pendingDefaultAdminSchedule); } function defaultAdminDelay() public view virtual returns (uint48) { uint48 schedule = _pendingDelaySchedule; return (_isScheduleSet(schedule) && _hasSchedulePassed(schedule)) ? _pendingDelay : _currentDelay; } function pendingDefaultAdminDelay() public view virtual returns (uint48 newDelay, uint48 schedule) { schedule = _pendingDelaySchedule; return (_isScheduleSet(schedule) && !_hasSchedulePassed(schedule)) ? (_pendingDelay, schedule) : (0, 0); } function defaultAdminDelayIncreaseWait() public view virtual returns (uint48) { return 5 days; } function beginDefaultAdminTransfer(address newAdmin) public virtual onlyRole(DEFAULT_ADMIN_ROLE) { _beginDefaultAdminTransfer(newAdmin); } function _beginDefaultAdminTransfer(address newAdmin) internal virtual { uint48 newSchedule = SafeCast.toUint48(block.timestamp) + defaultAdminDelay(); _setPendingDefaultAdmin(newAdmin, newSchedule); emit DefaultAdminTransferScheduled(newAdmin, newSchedule); } function cancelDefaultAdminTransfer() public virtual onlyRole(DEFAULT_ADMIN_ROLE) { _cancelDefaultAdminTransfer(); } function _cancelDefaultAdminTransfer() internal virtual { _setPendingDefaultAdmin(address(0), 0); } function acceptDefaultAdminTransfer() public virtual { (address newDefaultAdmin, ) = pendingDefaultAdmin(); if (_msgSender() != newDefaultAdmin) { revert AccessControlInvalidDefaultAdmin(_msgSender()); } _acceptDefaultAdminTransfer(); } function _acceptDefaultAdminTransfer() internal virtual { (address newAdmin, uint48 schedule) = pendingDefaultAdmin(); if (!_isScheduleSet(schedule) || !_hasSchedulePassed(schedule)) { revert AccessControlEnforcedDefaultAdminDelay(schedule); } _revokeRole(DEFAULT_ADMIN_ROLE, defaultAdmin()); _grantRole(DEFAULT_ADMIN_ROLE, newAdmin); delete _pendingDefaultAdmin; delete _pendingDefaultAdminSchedule; } function changeDefaultAdminDelay(uint48 newDelay) public virtual onlyRole(DEFAULT_ADMIN_ROLE) { _changeDefaultAdminDelay(newDelay); } function _changeDefaultAdminDelay(uint48 newDelay) internal virtual { uint48 newSchedule = SafeCast.toUint48(block.timestamp) + _delayChangeWait(newDelay); _setPendingDelay(newDelay, newSchedule); emit DefaultAdminDelayChangeScheduled(newDelay, newSchedule); } function rollbackDefaultAdminDelay() public virtual onlyRole(DEFAULT_ADMIN_ROLE) { _rollbackDefaultAdminDelay(); } function _rollbackDefaultAdminDelay() internal virtual { _setPendingDelay(0, 0); } function _delayChangeWait(uint48 newDelay) internal view virtual returns (uint48) { uint48 currentDelay = defaultAdminDelay(); return newDelay > currentDelay ? uint48(Math.min(newDelay, defaultAdminDelayIncreaseWait())) : currentDelay - newDelay; } function _setPendingDefaultAdmin(address newAdmin, uint48 newSchedule) private { (, uint48 oldSchedule) = pendingDefaultAdmin(); _pendingDefaultAdmin = newAdmin; _pendingDefaultAdminSchedule = newSchedule; if (_isScheduleSet(oldSchedule)) { emit DefaultAdminTransferCanceled(); } } function _setPendingDelay(uint48 newDelay, uint48 newSchedule) private { uint48 oldSchedule = _pendingDelaySchedule; if (_isScheduleSet(oldSchedule)) { if (_hasSchedulePassed(oldSchedule)) { _currentDelay = _pendingDelay; } else { emit DefaultAdminDelayChangeCanceled(); } } _pendingDelay = newDelay; _pendingDelaySchedule = newSchedule; } function _isScheduleSet(uint48 schedule) private pure returns (bool) { return schedule != 0; } function _hasSchedulePassed(uint48 schedule) private view returns (bool) { return schedule < block.timestamp; } } ", " pragma solidity ^0.8.24; import {IGovernor, Governor} from \"../Governor.sol\"; import {GovernorCountingSimple} from \"./GovernorCountingSimple.sol\"; import {Math} from \"../../utils/math/Math.sol\"; abstract contract GovernorCountingFractional is Governor { using Math for *; uint8 internal constant VOTE_TYPE_FRACTIONAL = 255; struct ProposalVote { uint256 againstVotes; uint256 forVotes; uint256 abstainVotes; mapping(address voter => uint256) usedVotes; } mapping(uint256 proposalId => ProposalVote) private _proposalVotes; error GovernorExceedRemainingWeight(address voter, uint256 usedVotes, uint256 remainingWeight); function COUNTING_MODE() public pure virtual override returns (string memory) { return \"support=bravo,fractional&quorum=for,abstain&params=fractional\"; } function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) { return usedVotes(proposalId, account) > 0; } function usedVotes(uint256 proposalId, address account) public view virtual returns (uint256) { return _proposalVotes[proposalId].usedVotes[account]; } function proposalVotes( uint256 proposalId ) public view virtual returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes) { ProposalVote storage proposalVote = _proposalVotes[proposalId]; return (proposalVote.againstVotes, proposalVote.forVotes, proposalVote.abstainVotes); } function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) { ProposalVote storage proposalVote = _proposalVotes[proposalId]; return quorum(proposalSnapshot(proposalId)) <= proposalVote.forVotes + proposalVote.abstainVotes; } function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) { ProposalVote storage proposalVote = _proposalVotes[proposalId]; return proposalVote.forVotes > proposalVote.againstVotes; } function _countVote( uint256 proposalId, address account, uint8 support, uint256 totalWeight, bytes memory params ) internal virtual override returns (uint256) { (, uint256 remainingWeight) = totalWeight.trySub(usedVotes(proposalId, account)); if (remainingWeight == 0) { revert GovernorAlreadyCastVote(account); } uint256 againstVotes = 0; uint256 forVotes = 0; uint256 abstainVotes = 0; uint256 usedWeight = 0; if (support == uint8(GovernorCountingSimple.VoteType.Against)) { if (params.length != 0) revert GovernorInvalidVoteParams(); usedWeight = againstVotes = remainingWeight; } else if (support == uint8(GovernorCountingSimple.VoteType.For)) { if (params.length != 0) revert GovernorInvalidVoteParams(); usedWeight = forVotes = remainingWeight; } else if (support == uint8(GovernorCountingSimple.VoteType.Abstain)) { if (params.length != 0) revert GovernorInvalidVoteParams(); usedWeight = abstainVotes = remainingWeight; } else if (support == VOTE_TYPE_FRACTIONAL) { if (params.length != 0x30) revert GovernorInvalidVoteParams(); assembly (\"memory-safe\") { againstVotes := shr(128, mload(add(params, 0x20))) forVotes := shr(128, mload(add(params, 0x30))) abstainVotes := shr(128, mload(add(params, 0x40))) usedWeight := add(add(againstVotes, forVotes), abstainVotes) } if (usedWeight > remainingWeight) { revert GovernorExceedRemainingWeight(account, usedWeight, remainingWeight); } } else { revert GovernorInvalidVoteType(); } ProposalVote storage details = _proposalVotes[proposalId]; if (againstVotes > 0) details.againstVotes += againstVotes; if (forVotes > 0) details.forVotes += forVotes; if (abstainVotes > 0) details.abstainVotes += abstainVotes; details.usedVotes[account] += usedWeight; return usedWeight; } } ", " pragma solidity ^0.8.20; import {SafeCast} from \"../utils/math/SafeCast.sol\"; import {VestingWallet} from \"./VestingWallet.sol\"; abstract contract VestingWalletCliff is VestingWallet { using SafeCast for *; uint64 private immutable _cliff; error InvalidCliffDuration(uint64 cliffSeconds, uint64 durationSeconds); constructor(uint64 cliffSeconds) { if (cliffSeconds > duration()) { revert InvalidCliffDuration(cliffSeconds, duration().toUint64()); } _cliff = start().toUint64() + cliffSeconds; } function cliff() public view virtual returns (uint256) { return _cliff; } function _vestingSchedule( uint256 totalAllocation, uint64 timestamp ) internal view virtual override returns (uint256) { return timestamp < cliff() ? 0 : super._vestingSchedule(totalAllocation, timestamp); } } ", " pragma solidity >=0.6.2; import {IERC20} from \"./IERC20.sol\"; import {IERC165} from \"./IERC165.sol\"; interface IERC1363 is IERC20, IERC165 { function transferAndCall(address to, uint256 value) external returns (bool); function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool); function transferFromAndCall(address from, address to, uint256 value) external returns (bool); function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool); function approveAndCall(address spender, uint256 value) external returns (bool); function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool); } ", " pragma solidity >=0.4.16; interface IERC5313 { function owner() external view returns (address); } ", " pragma solidity ^0.8.0; contract SafeMathExample { uint256 public balance = 250; function add(uint256 _value) public { balance = balance + _value; } } ", " pragma solidity >=0.4.16; interface IERC5267 { event EIP712DomainChanged(); function eip712Domain() external view returns ( bytes1 fields, string memory name, string memory version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] memory extensions ); } ", " pragma solidity >=0.6.2; import {IERC1155MetadataURI} from \"../token/ERC1155/extensions/IERC1155MetadataURI.sol\"; ", " pragma solidity ^0.8.24; import {IERC5805} from \"../../interfaces/IERC5805.sol\"; import {Context} from \"../../utils/Context.sol\"; import {Nonces} from \"../../utils/Nonces.sol\"; import {EIP712} from \"../../utils/cryptography/EIP712.sol\"; import {Checkpoints} from \"../../utils/structs/Checkpoints.sol\"; import {SafeCast} from \"../../utils/math/SafeCast.sol\"; import {ECDSA} from \"../../utils/cryptography/ECDSA.sol\"; import {Time} from \"../../utils/types/Time.sol\"; abstract contract Votes is Context, EIP712, Nonces, IERC5805 { using Checkpoints for Checkpoints.Trace208; bytes32 private constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\"); mapping(address account => address) private _delegatee; mapping(address delegatee => Checkpoints.Trace208) private _delegateCheckpoints; Checkpoints.Trace208 private _totalCheckpoints; error ERC6372InconsistentClock(); error ERC5805FutureLookup(uint256 timepoint, uint48 clock); function clock() public view virtual returns (uint48) { return Time.blockNumber(); } function CLOCK_MODE() public view virtual returns (string memory) { if (clock() != Time.blockNumber()) { revert ERC6372InconsistentClock(); } return \"mode=blocknumber&from=default\"; } function _validateTimepoint(uint256 timepoint) internal view returns (uint48) { uint48 currentTimepoint = clock(); if (timepoint >= currentTimepoint) revert ERC5805FutureLookup(timepoint, currentTimepoint); return SafeCast.toUint48(timepoint); } function getVotes(address account) public view virtual returns (uint256) { return _delegateCheckpoints[account].latest(); } function getPastVotes(address account, uint256 timepoint) public view virtual returns (uint256) { return _delegateCheckpoints[account].upperLookupRecent(_validateTimepoint(timepoint)); } function getPastTotalSupply(uint256 timepoint) public view virtual returns (uint256) { return _totalCheckpoints.upperLookupRecent(_validateTimepoint(timepoint)); } function _getTotalSupply() internal view virtual returns (uint256) { return _totalCheckpoints.latest(); } function delegates(address account) public view virtual returns (address) { return _delegatee[account]; } function delegate(address delegatee) public virtual { address account = _msgSender(); _delegate(account, delegatee); } function delegateBySig( address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s ) public virtual { if (block.timestamp > expiry) { revert VotesExpiredSignature(expiry); } address signer = ECDSA.recover( _hashTypedDataV4(keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry))), v, r, s ); _useCheckedNonce(signer, nonce); _delegate(signer, delegatee); } function _delegate(address account, address delegatee) internal virtual { address oldDelegate = delegates(account); _delegatee[account] = delegatee; emit DelegateChanged(account, oldDelegate, delegatee); _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account)); } function _transferVotingUnits(address from, address to, uint256 amount) internal virtual { if (from == address(0)) { _push(_totalCheckpoints, _add, SafeCast.toUint208(amount)); } if (to == address(0)) { _push(_totalCheckpoints, _subtract, SafeCast.toUint208(amount)); } _moveDelegateVotes(delegates(from), delegates(to), amount); } function _moveDelegateVotes(address from, address to, uint256 amount) internal virtual { if (from != to && amount > 0) { if (from != address(0)) { (uint256 oldValue, uint256 newValue) = _push( _delegateCheckpoints[from], _subtract, SafeCast.toUint208(amount) ); emit DelegateVotesChanged(from, oldValue, newValue); } if (to != address(0)) { (uint256 oldValue, uint256 newValue) = _push( _delegateCheckpoints[to], _add, SafeCast.toUint208(amount) ); emit DelegateVotesChanged(to, oldValue, newValue); } } } function _numCheckpoints(address account) internal view virtual returns (uint32) { return SafeCast.toUint32(_delegateCheckpoints[account].length()); } function _checkpoints( address account, uint32 pos ) internal view virtual returns (Checkpoints.Checkpoint208 memory) { return _delegateCheckpoints[account].at(pos); } function _push( Checkpoints.Trace208 storage store, function(uint208, uint208) view returns (uint208) op, uint208 delta ) private returns (uint208 oldValue, uint208 newValue) { return store.push(clock(), op(store.latest(), delta)); } function _add(uint208 a, uint208 b) private pure returns (uint208) { return a + b; } function _subtract(uint208 a, uint208 b) private pure returns (uint208) { return a - b; } function _getVotingUnits(address) internal view virtual returns (uint256); } ", " pragma solidity ^0.8.20; import {ERC7579Utils, Mode, CallType, ExecType, ModeSelector} from \"../utils/draft-ERC7579Utils.sol\"; import {IERC7821} from \"../../interfaces/draft-IERC7821.sol\"; import {Account} from \"../Account.sol\"; abstract contract ERC7821 is IERC7821 { using ERC7579Utils for *; error UnsupportedExecutionMode(); function execute(bytes32 mode, bytes calldata executionData) public payable virtual { if (!_erc7821AuthorizedExecutor(msg.sender, mode, executionData)) revert Account.AccountUnauthorized(msg.sender); if (!supportsExecutionMode(mode)) revert UnsupportedExecutionMode(); executionData.execBatch(ERC7579Utils.EXECTYPE_DEFAULT); } function supportsExecutionMode(bytes32 mode) public view virtual returns (bool result) { (CallType callType, ExecType execType, ModeSelector modeSelector, ) = Mode.wrap(mode).decodeMode(); return callType == ERC7579Utils.CALLTYPE_BATCH && execType == ERC7579Utils.EXECTYPE_DEFAULT && modeSelector == ModeSelector.wrap(0x00000000); } function _erc7821AuthorizedExecutor( address caller, bytes32 , bytes calldata ) internal view virtual returns (bool) { return caller == address(this); } } ", " pragma solidity ^0.8.26; import {IERC7579Hook, MODULE_TYPE_HOOK} from \"../../interfaces/draft-IERC7579.sol\"; import {ERC7579Utils, Mode} from \"../../account/utils/draft-ERC7579Utils.sol\"; import {AccountERC7579} from \"./draft-AccountERC7579.sol\"; abstract contract AccountERC7579Hooked is AccountERC7579 { address private _hook; error ERC7579HookModuleAlreadyPresent(address hook); modifier withHook() { address hook_ = hook(); bytes memory hookData; if (hook_ != address(0)) hookData = IERC7579Hook(hook_).preCheck(msg.sender, msg.value, msg.data); _; if (hook_ != address(0)) IERC7579Hook(hook_).postCheck(hookData); } function accountId() public view virtual override returns (string memory) { return \"@openzeppelin/community-contracts.AccountERC7579Hooked.v0.0.0\"; } function hook() public view virtual returns (address) { return _hook; } function supportsModule(uint256 moduleTypeId) public view virtual override returns (bool) { return moduleTypeId == MODULE_TYPE_HOOK || super.supportsModule(moduleTypeId); } function isModuleInstalled( uint256 moduleTypeId, address module, bytes calldata data ) public view virtual override returns (bool) { return (moduleTypeId == MODULE_TYPE_HOOK && module == hook()) || super.isModuleInstalled(moduleTypeId, module, data); } function _installModule( uint256 moduleTypeId, address module, bytes memory initData ) internal virtual override withHook { if (moduleTypeId == MODULE_TYPE_HOOK) { require(_hook == address(0), ERC7579HookModuleAlreadyPresent(_hook)); _hook = module; } super._installModule(moduleTypeId, module, initData); } function _uninstallModule( uint256 moduleTypeId, address module, bytes memory deInitData ) internal virtual override withHook { if (moduleTypeId == MODULE_TYPE_HOOK) { require(_hook == module, ERC7579Utils.ERC7579UninstalledModule(moduleTypeId, module)); _hook = address(0); } super._uninstallModule(moduleTypeId, module, deInitData); } function _execute( Mode mode, bytes calldata executionCalldata ) internal virtual override withHook returns (bytes[] memory) { return super._execute(mode, executionCalldata); } function _fallback() internal virtual override withHook returns (bytes memory) { return super._fallback(); } } ", " pragma solidity >=0.8.4; interface IAccessControl { error AccessControlUnauthorizedAccount(address account, bytes32 neededRole); error AccessControlBadConfirmation(); event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole); event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender); event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender); function hasRole(bytes32 role, address account) external view returns (bool); function getRoleAdmin(bytes32 role) external view returns (bytes32); function grantRole(bytes32 role, address account) external; function revokeRole(bytes32 role, address account) external; function renounceRole(bytes32 role, address callerConfirmation) external; } ", " pragma solidity >=0.6.2; import {IERC20Metadata} from \"../token/ERC20/extensions/IERC20Metadata.sol\"; ", " pragma solidity ^0.8.20; library EIP7702Utils { bytes3 internal constant EIP7702_PREFIX = 0xef0100; function fetchDelegate(address account) internal view returns (address) { bytes23 delegation = bytes23(account.code); return bytes3(delegation) == EIP7702_PREFIX ? address(bytes20(delegation << 24)) : address(0); } } ", " pragma solidity >=0.8.4; import {IERC165} from \"../interfaces/IERC165.sol\"; import {IERC6372} from \"../interfaces/IERC6372.sol\"; interface IGovernor is IERC165, IERC6372 { enum ProposalState { Pending, Active, Canceled, Defeated, Succeeded, Queued, Expired, Executed } error GovernorInvalidProposalLength(uint256 targets, uint256 calldatas, uint256 values); error GovernorAlreadyCastVote(address voter); error GovernorDisabledDeposit(); error GovernorOnlyExecutor(address account); error GovernorNonexistentProposal(uint256 proposalId); error GovernorUnexpectedProposalState(uint256 proposalId, ProposalState current, bytes32 expectedStates); error GovernorInvalidVotingPeriod(uint256 votingPeriod); error GovernorInsufficientProposerVotes(address proposer, uint256 votes, uint256 threshold); error GovernorRestrictedProposer(address proposer); error GovernorInvalidVoteType(); error GovernorInvalidVoteParams(); error GovernorQueueNotImplemented(); error GovernorNotQueuedProposal(uint256 proposalId); error GovernorAlreadyQueuedProposal(uint256 proposalId); error GovernorInvalidSignature(address voter); error GovernorUnableToCancel(uint256 proposalId, address account); event ProposalCreated( uint256 proposalId, address proposer, address[] targets, uint256[] values, string[] signatures, bytes[] calldatas, uint256 voteStart, uint256 voteEnd, string description ); event ProposalQueued(uint256 proposalId, uint256 etaSeconds); event ProposalExecuted(uint256 proposalId); event ProposalCanceled(uint256 proposalId); event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 weight, string reason); event VoteCastWithParams( address indexed voter, uint256 proposalId, uint8 support, uint256 weight, string reason, bytes params ); function name() external view returns (string memory); function version() external view returns (string memory); function COUNTING_MODE() external view returns (string memory); function hashProposal( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) external pure returns (uint256); function getProposalId( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) external view returns (uint256); function state(uint256 proposalId) external view returns (ProposalState); function proposalThreshold() external view returns (uint256); function proposalSnapshot(uint256 proposalId) external view returns (uint256); function proposalDeadline(uint256 proposalId) external view returns (uint256); function proposalProposer(uint256 proposalId) external view returns (address); function proposalEta(uint256 proposalId) external view returns (uint256); function proposalNeedsQueuing(uint256 proposalId) external view returns (bool); function votingDelay() external view returns (uint256); function votingPeriod() external view returns (uint256); function quorum(uint256 timepoint) external view returns (uint256); function getVotes(address account, uint256 timepoint) external view returns (uint256); function getVotesWithParams( address account, uint256 timepoint, bytes memory params ) external view returns (uint256); function hasVoted(uint256 proposalId, address account) external view returns (bool); function propose( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, string memory description ) external returns (uint256 proposalId); function queue( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) external returns (uint256 proposalId); function execute( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) external payable returns (uint256 proposalId); function cancel( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) external returns (uint256 proposalId); function castVote(uint256 proposalId, uint8 support) external returns (uint256 balance); function castVoteWithReason( uint256 proposalId, uint8 support, string calldata reason ) external returns (uint256 balance); function castVoteWithReasonAndParams( uint256 proposalId, uint8 support, string calldata reason, bytes memory params ) external returns (uint256 balance); function castVoteBySig( uint256 proposalId, uint8 support, address voter, bytes memory signature ) external returns (uint256 balance); function castVoteWithReasonAndParamsBySig( uint256 proposalId, uint8 support, address voter, string calldata reason, bytes memory params, bytes memory signature ) external returns (uint256 balance); } ", " pragma solidity ^0.8.24; import {ERC2771Context} from \"./ERC2771Context.sol\"; import {ECDSA} from \"../utils/cryptography/ECDSA.sol\"; import {EIP712} from \"../utils/cryptography/EIP712.sol\"; import {Nonces} from \"../utils/Nonces.sol\"; import {Address} from \"../utils/Address.sol\"; import {Errors} from \"../utils/Errors.sol\"; contract ERC2771Forwarder is EIP712, Nonces { using ECDSA for bytes32; struct ForwardRequestData { address from; address to; uint256 value; uint256 gas; uint48 deadline; bytes data; bytes signature; } bytes32 internal constant FORWARD_REQUEST_TYPEHASH = keccak256( \"ForwardRequest(address from,address to,uint256 value,uint256 gas,uint256 nonce,uint48 deadline,bytes data)\" ); event ExecutedForwardRequest(address indexed signer, uint256 nonce, bool success); error ERC2771ForwarderInvalidSigner(address signer, address from); error ERC2771ForwarderMismatchedValue(uint256 requestedValue, uint256 msgValue); error ERC2771ForwarderExpiredRequest(uint48 deadline); error ERC2771UntrustfulTarget(address target, address forwarder); constructor(string memory name) EIP712(name, \"1\") {} function verify(ForwardRequestData calldata request) public view virtual returns (bool) { (bool isTrustedForwarder, bool active, bool signerMatch, ) = _validate(request); return isTrustedForwarder && active && signerMatch; } function execute(ForwardRequestData calldata request) public payable virtual { if (msg.value != request.value) { revert ERC2771ForwarderMismatchedValue(request.value, msg.value); } if (!_execute(request, true)) { revert Errors.FailedCall(); } } function executeBatch( ForwardRequestData[] calldata requests, address payable refundReceiver ) public payable virtual { bool atomic = refundReceiver == address(0); uint256 requestsValue; uint256 refundValue; for (uint256 i; i < requests.length; ++i) { requestsValue += requests[i].value; bool success = _execute(requests[i], atomic); if (!success) { refundValue += requests[i].value; } } if (requestsValue != msg.value) { revert ERC2771ForwarderMismatchedValue(requestsValue, msg.value); } if (refundValue != 0) { Address.sendValue(refundReceiver, refundValue); } } function _validate( ForwardRequestData calldata request ) internal view virtual returns (bool isTrustedForwarder, bool active, bool signerMatch, address signer) { (bool isValid, address recovered) = _recoverForwardRequestSigner(request); return ( _isTrustedByTarget(request.to), request.deadline >= block.timestamp, isValid && recovered == request.from, recovered ); } function _recoverForwardRequestSigner( ForwardRequestData calldata request ) internal view virtual returns (bool isValid, address signer) { (address recovered, ECDSA.RecoverError err, ) = _hashTypedDataV4( keccak256( abi.encode( FORWARD_REQUEST_TYPEHASH, request.from, request.to, request.value, request.gas, nonces(request.from), request.deadline, keccak256(request.data) ) ) ).tryRecoverCalldata(request.signature); return (err == ECDSA.RecoverError.NoError, recovered); } function _execute( ForwardRequestData calldata request, bool requireValidRequest ) internal virtual returns (bool success) { (bool isTrustedForwarder, bool active, bool signerMatch, address signer) = _validate(request); if (requireValidRequest) { if (!isTrustedForwarder) { revert ERC2771UntrustfulTarget(request.to, address(this)); } if (!active) { revert ERC2771ForwarderExpiredRequest(request.deadline); } if (!signerMatch) { revert ERC2771ForwarderInvalidSigner(signer, request.from); } } if (isTrustedForwarder && signerMatch && active) { uint256 currentNonce = _useNonce(signer); uint256 reqGas = request.gas; address to = request.to; uint256 value = request.value; bytes memory data = abi.encodePacked(request.data, request.from); uint256 gasLeft; assembly (\"memory-safe\") { success := call(reqGas, to, value, add(data, 0x20), mload(data), 0x00, 0x00) gasLeft := gas() } _checkForwardedGas(gasLeft, request); emit ExecutedForwardRequest(signer, currentNonce, success); } } function _isTrustedByTarget(address target) internal view virtual returns (bool) { bytes memory encodedParams = abi.encodeCall(ERC2771Context.isTrustedForwarder, (address(this))); bool success; uint256 returnSize; uint256 returnValue; assembly (\"memory-safe\") { success := staticcall(gas(), target, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20) returnSize := returndatasize() returnValue := mload(0x00) } return success && returnSize >= 0x20 && returnValue > 0; } function _checkForwardedGas(uint256 gasLeft, ForwardRequestData calldata request) private pure { if (gasLeft < request.gas / 63) { assembly (\"memory-safe\") { invalid() } } } } ", " pragma solidity >=0.8.4; interface IVotes { error VotesExpiredSignature(uint256 expiry); event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate); event DelegateVotesChanged(address indexed delegate, uint256 previousVotes, uint256 newVotes); function getVotes(address account) external view returns (uint256); function getPastVotes(address account, uint256 timepoint) external view returns (uint256); function getPastTotalSupply(uint256 timepoint) external view returns (uint256); function delegates(address account) external view returns (address); function delegate(address delegatee) external; function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external; } ", " pragma solidity >=0.4.11; interface IERC2309 { event ConsecutiveTransfer( uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress ); } ", " pragma solidity >=0.8.4; import {PackedUserOperation} from \"./draft-IERC4337.sol\"; uint256 constant VALIDATION_SUCCESS = 0; uint256 constant VALIDATION_FAILED = 1; uint256 constant MODULE_TYPE_VALIDATOR = 1; uint256 constant MODULE_TYPE_EXECUTOR = 2; uint256 constant MODULE_TYPE_FALLBACK = 3; uint256 constant MODULE_TYPE_HOOK = 4; interface IERC7579Module { function onInstall(bytes calldata data) external; function onUninstall(bytes calldata data) external; function isModuleType(uint256 moduleTypeId) external view returns (bool); } interface IERC7579Validator is IERC7579Module { function validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash) external returns (uint256); function isValidSignatureWithSender( address sender, bytes32 hash, bytes calldata signature ) external view returns (bytes4); } interface IERC7579Hook is IERC7579Module { function preCheck( address msgSender, uint256 value, bytes calldata msgData ) external returns (bytes memory hookData); function postCheck(bytes calldata hookData) external; } struct Execution { address target; uint256 value; bytes callData; } interface IERC7579Execution { function execute(bytes32 mode, bytes calldata executionCalldata) external payable; function executeFromExecutor( bytes32 mode, bytes calldata executionCalldata ) external payable returns (bytes[] memory returnData); } interface IERC7579AccountConfig { function accountId() external view returns (string memory accountImplementationId); function supportsExecutionMode(bytes32 encodedMode) external view returns (bool); function supportsModule(uint256 moduleTypeId) external view returns (bool); } interface IERC7579ModuleConfig { event ModuleInstalled(uint256 moduleTypeId, address module); event ModuleUninstalled(uint256 moduleTypeId, address module); function installModule(uint256 moduleTypeId, address module, bytes calldata initData) external; function uninstallModule(uint256 moduleTypeId, address module, bytes calldata deInitData) external; function isModuleInstalled( uint256 moduleTypeId, address module, bytes calldata additionalContext ) external view returns (bool); } ", " pragma solidity >=0.8.4; interface IERC7786GatewaySource { event MessageSent( bytes32 indexed sendId, bytes sender, bytes recipient, bytes payload, uint256 value, bytes[] attributes ); error UnsupportedAttribute(bytes4 selector); function supportsAttribute(bytes4 selector) external view returns (bool); function sendMessage( bytes calldata recipient, bytes calldata payload, bytes[] calldata attributes ) external payable returns (bytes32 sendId); } interface IERC7786Recipient { function receiveMessage( bytes32 receiveId, bytes calldata sender, bytes calldata payload ) external payable returns (bytes4); } ", " pragma solidity ^0.8.24; import {Governor} from \"../Governor.sol\"; import {Math} from \"../../utils/math/Math.sol\"; abstract contract GovernorPreventLateQuorum is Governor { uint48 private _voteExtension; mapping(uint256 proposalId => uint48) private _extendedDeadlines; event ProposalExtended(uint256 indexed proposalId, uint64 extendedDeadline); event LateQuorumVoteExtensionSet(uint64 oldVoteExtension, uint64 newVoteExtension); constructor(uint48 initialVoteExtension) { _setLateQuorumVoteExtension(initialVoteExtension); } function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) { return Math.max(super.proposalDeadline(proposalId), _extendedDeadlines[proposalId]); } function _tallyUpdated(uint256 proposalId) internal virtual override { super._tallyUpdated(proposalId); if (_extendedDeadlines[proposalId] == 0 && _quorumReached(proposalId)) { uint48 extendedDeadline = clock() + lateQuorumVoteExtension(); if (extendedDeadline > proposalDeadline(proposalId)) { emit ProposalExtended(proposalId, extendedDeadline); } _extendedDeadlines[proposalId] = extendedDeadline; } } function lateQuorumVoteExtension() public view virtual returns (uint48) { return _voteExtension; } function setLateQuorumVoteExtension(uint48 newVoteExtension) public virtual onlyGovernance { _setLateQuorumVoteExtension(newVoteExtension); } function _setLateQuorumVoteExtension(uint48 newVoteExtension) internal virtual { emit LateQuorumVoteExtensionSet(_voteExtension, newVoteExtension); _voteExtension = newVoteExtension; } } ", " pragma solidity >=0.6.2; import {IERC20} from \"../token/ERC20/IERC20.sol\"; import {IERC20Metadata} from \"../token/ERC20/extensions/IERC20Metadata.sol\"; interface IERC4626 is IERC20, IERC20Metadata { event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares); event Withdraw( address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares ); function asset() external view returns (address assetTokenAddress); function totalAssets() external view returns (uint256 totalManagedAssets); function convertToShares(uint256 assets) external view returns (uint256 shares); function convertToAssets(uint256 shares) external view returns (uint256 assets); function maxDeposit(address receiver) external view returns (uint256 maxAssets); function previewDeposit(uint256 assets) external view returns (uint256 shares); function deposit(uint256 assets, address receiver) external returns (uint256 shares); function maxMint(address receiver) external view returns (uint256 maxShares); function previewMint(uint256 shares) external view returns (uint256 assets); function mint(uint256 shares, address receiver) external returns (uint256 assets); function maxWithdraw(address owner) external view returns (uint256 maxAssets); function previewWithdraw(uint256 assets) external view returns (uint256 shares); function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares); function maxRedeem(address owner) external view returns (uint256 maxShares); function previewRedeem(uint256 shares) external view returns (uint256 assets); function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets); } ", " pragma solidity >=0.6.2; import {IERC165} from \"./IERC165.sol\"; interface IERC7802 is IERC165 { event CrosschainMint(address indexed to, uint256 amount, address indexed sender); event CrosschainBurn(address indexed from, uint256 amount, address indexed sender); function crosschainMint(address _to, uint256 _amount) external; function crosschainBurn(address _from, uint256 _amount) external; } ", " pragma solidity ^0.8.24; import {Governor} from \"../Governor.sol\"; import {IVotes} from \"../utils/IVotes.sol\"; import {IERC5805} from \"../../interfaces/IERC5805.sol\"; import {Time} from \"../../utils/types/Time.sol\"; abstract contract GovernorVotes is Governor { IERC5805 private immutable _token; constructor(IVotes tokenAddress) { _token = IERC5805(address(tokenAddress)); } function token() public view virtual returns (IERC5805) { return _token; } function clock() public view virtual override returns (uint48) { try token().clock() returns (uint48 timepoint) { return timepoint; } catch { return Time.blockNumber(); } } function CLOCK_MODE() public view virtual override returns (string memory) { try token().CLOCK_MODE() returns (string memory clockmode) { return clockmode; } catch { return \"mode=blocknumber&from=default\"; } } function _getVotes( address account, uint256 timepoint, bytes memory ) internal view virtual override returns (uint256) { return token().getPastVotes(account, timepoint); } } ", " pragma solidity ^0.8.24; import {SignatureChecker} from \"../../utils/cryptography/SignatureChecker.sol\"; import {SafeCast} from \"../../utils/math/SafeCast.sol\"; import {VotesExtended} from \"../utils/VotesExtended.sol\"; import {GovernorVotes} from \"./GovernorVotes.sol\"; import {IGovernor, Governor} from \"../Governor.sol\"; abstract contract GovernorCountingOverridable is GovernorVotes { bytes32 public constant OVERRIDE_BALLOT_TYPEHASH = keccak256(\"OverrideBallot(uint256 proposalId,uint8 support,address voter,uint256 nonce,string reason)\"); enum VoteType { Against, For, Abstain } struct VoteReceipt { uint8 casted; bool hasOverridden; uint208 overriddenWeight; } struct ProposalVote { uint256[3] votes; mapping(address voter => VoteReceipt) voteReceipt; } event VoteReduced(address indexed delegate, uint256 proposalId, uint8 support, uint256 weight); event OverrideVoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 weight, string reason); error GovernorAlreadyOverriddenVote(address account); mapping(uint256 proposalId => ProposalVote) private _proposalVotes; function COUNTING_MODE() public pure virtual override returns (string memory) { return \"support=bravo,override&quorum=for,abstain&overridable=true\"; } function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) { return _proposalVotes[proposalId].voteReceipt[account].casted != 0; } function hasVotedOverride(uint256 proposalId, address account) public view virtual returns (bool) { return _proposalVotes[proposalId].voteReceipt[account].hasOverridden; } function proposalVotes( uint256 proposalId ) public view virtual returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes) { uint256[3] storage votes = _proposalVotes[proposalId].votes; return (votes[uint8(VoteType.Against)], votes[uint8(VoteType.For)], votes[uint8(VoteType.Abstain)]); } function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) { uint256[3] storage votes = _proposalVotes[proposalId].votes; return quorum(proposalSnapshot(proposalId)) <= votes[uint8(VoteType.For)] + votes[uint8(VoteType.Abstain)]; } function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) { uint256[3] storage votes = _proposalVotes[proposalId].votes; return votes[uint8(VoteType.For)] > votes[uint8(VoteType.Against)]; } function _countVote( uint256 proposalId, address account, uint8 support, uint256 totalWeight, bytes memory ) internal virtual override returns (uint256) { ProposalVote storage proposalVote = _proposalVotes[proposalId]; if (support > uint8(VoteType.Abstain)) { revert GovernorInvalidVoteType(); } if (proposalVote.voteReceipt[account].casted != 0) { revert GovernorAlreadyCastVote(account); } totalWeight -= proposalVote.voteReceipt[account].overriddenWeight; proposalVote.votes[support] += totalWeight; proposalVote.voteReceipt[account].casted = support + 1; return totalWeight; } function _countOverride(uint256 proposalId, address account, uint8 support) internal virtual returns (uint256) { ProposalVote storage proposalVote = _proposalVotes[proposalId]; if (support > uint8(VoteType.Abstain)) { revert GovernorInvalidVoteType(); } if (proposalVote.voteReceipt[account].hasOverridden) { revert GovernorAlreadyOverriddenVote(account); } uint256 snapshot = proposalSnapshot(proposalId); uint256 overriddenWeight = VotesExtended(address(token())).getPastBalanceOf(account, snapshot); address delegate = VotesExtended(address(token())).getPastDelegate(account, snapshot); uint8 delegateCasted = proposalVote.voteReceipt[delegate].casted; proposalVote.voteReceipt[account].hasOverridden = true; proposalVote.votes[support] += overriddenWeight; if (delegateCasted == 0) { proposalVote.voteReceipt[delegate].overriddenWeight += SafeCast.toUint208(overriddenWeight); } else { uint8 delegateSupport = delegateCasted - 1; proposalVote.votes[delegateSupport] -= overriddenWeight; emit VoteReduced(delegate, proposalId, delegateSupport, overriddenWeight); } return overriddenWeight; } function _castOverride( uint256 proposalId, address account, uint8 support, string calldata reason ) internal virtual returns (uint256) { _validateStateBitmap(proposalId, _encodeStateBitmap(ProposalState.Active)); uint256 overriddenWeight = _countOverride(proposalId, account, support); emit OverrideVoteCast(account, proposalId, support, overriddenWeight, reason); _tallyUpdated(proposalId); return overriddenWeight; } function castOverrideVote( uint256 proposalId, uint8 support, string calldata reason ) public virtual returns (uint256) { address voter = _msgSender(); return _castOverride(proposalId, voter, support, reason); } function castOverrideVoteBySig( uint256 proposalId, uint8 support, address voter, string calldata reason, bytes calldata signature ) public virtual returns (uint256) { bool valid = SignatureChecker.isValidSignatureNow( voter, _hashTypedDataV4( keccak256( abi.encode( OVERRIDE_BALLOT_TYPEHASH, proposalId, support, voter, _useNonce(voter), keccak256(bytes(reason)) ) ) ), signature ); if (!valid) { revert GovernorInvalidSignature(voter); } return _castOverride(proposalId, voter, support, reason); } } ", " pragma solidity ^0.8.24; import {Governor} from \"../Governor.sol\"; abstract contract GovernorProposalGuardian is Governor { address private _proposalGuardian; event ProposalGuardianSet(address oldProposalGuardian, address newProposalGuardian); function proposalGuardian() public view virtual returns (address) { return _proposalGuardian; } function setProposalGuardian(address newProposalGuardian) public virtual onlyGovernance { _setProposalGuardian(newProposalGuardian); } function _setProposalGuardian(address newProposalGuardian) internal virtual { emit ProposalGuardianSet(_proposalGuardian, newProposalGuardian); _proposalGuardian = newProposalGuardian; } function _validateCancel(uint256 proposalId, address caller) internal view virtual override returns (bool) { address guardian = proposalGuardian(); return guardian == caller || (guardian == address(0) && caller == proposalProposer(proposalId)) || super._validateCancel(proposalId, caller); } } ", " pragma solidity >=0.6.2; import {IERC165} from \"./IERC165.sol\"; import {IERC721} from \"./IERC721.sol\"; interface IERC4906 is IERC165, IERC721 { event MetadataUpdate(uint256 _tokenId); event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId); } ", " pragma solidity >=0.8.4; import {IAccessControl} from \"../IAccessControl.sol\"; interface IAccessControlDefaultAdminRules is IAccessControl { error AccessControlInvalidDefaultAdmin(address defaultAdmin); error AccessControlEnforcedDefaultAdminRules(); error AccessControlEnforcedDefaultAdminDelay(uint48 schedule); event DefaultAdminTransferScheduled(address indexed newAdmin, uint48 acceptSchedule); event DefaultAdminTransferCanceled(); event DefaultAdminDelayChangeScheduled(uint48 newDelay, uint48 effectSchedule); event DefaultAdminDelayChangeCanceled(); function defaultAdmin() external view returns (address); function pendingDefaultAdmin() external view returns (address newAdmin, uint48 acceptSchedule); function defaultAdminDelay() external view returns (uint48); function pendingDefaultAdminDelay() external view returns (uint48 newDelay, uint48 effectSchedule); function beginDefaultAdminTransfer(address newAdmin) external; function cancelDefaultAdminTransfer() external; function acceptDefaultAdminTransfer() external; function changeDefaultAdminDelay(uint48 newDelay) external; function rollbackDefaultAdminDelay() external; function defaultAdminDelayIncreaseWait() external view returns (uint48); } ", " pragma solidity ^0.8.24; import {Governor} from \"../Governor.sol\"; import {Nonces} from \"../../utils/Nonces.sol\"; import {NoncesKeyed} from \"../../utils/NoncesKeyed.sol\"; import {SignatureChecker} from \"../../utils/cryptography/SignatureChecker.sol\"; abstract contract GovernorNoncesKeyed is Governor, NoncesKeyed { function _useCheckedNonce(address owner, uint256 nonce) internal virtual override(Nonces, NoncesKeyed) { super._useCheckedNonce(owner, nonce); } function _validateVoteSig( uint256 proposalId, uint8 support, address voter, bytes memory signature ) internal virtual override returns (bool) { if ( SignatureChecker.isValidSignatureNow( voter, _hashTypedDataV4( keccak256( abi.encode(BALLOT_TYPEHASH, proposalId, support, voter, nonces(voter, uint192(proposalId))) ) ), signature ) ) { _useNonce(voter, uint192(proposalId)); return true; } else { return super._validateVoteSig(proposalId, support, voter, signature); } } function _validateExtendedVoteSig( uint256 proposalId, uint8 support, address voter, string memory reason, bytes memory params, bytes memory signature ) internal virtual override returns (bool) { if ( SignatureChecker.isValidSignatureNow( voter, _hashTypedDataV4( keccak256( abi.encode( EXTENDED_BALLOT_TYPEHASH, proposalId, support, voter, nonces(voter, uint192(proposalId)), keccak256(bytes(reason)), keccak256(params) ) ) ), signature ) ) { _useNonce(voter, uint192(proposalId)); return true; } else { return super._validateExtendedVoteSig(proposalId, support, voter, reason, params, signature); } } } ", " pragma solidity ^0.8.20; import {Execution} from \"../../interfaces/draft-IERC7579.sol\"; import {Packing} from \"../../utils/Packing.sol\"; import {Address} from \"../../utils/Address.sol\"; type Mode is bytes32; type CallType is bytes1; type ExecType is bytes1; type ModeSelector is bytes4; type ModePayload is bytes22; library ERC7579Utils { using Packing for *; CallType internal constant CALLTYPE_SINGLE = CallType.wrap(0x00); CallType internal constant CALLTYPE_BATCH = CallType.wrap(0x01); CallType internal constant CALLTYPE_DELEGATECALL = CallType.wrap(0xFF); ExecType internal constant EXECTYPE_DEFAULT = ExecType.wrap(0x00); ExecType internal constant EXECTYPE_TRY = ExecType.wrap(0x01); event ERC7579TryExecuteFail(uint256 batchExecutionIndex, bytes returndata); error ERC7579UnsupportedCallType(CallType callType); error ERC7579UnsupportedExecType(ExecType execType); error ERC7579MismatchedModuleTypeId(uint256 moduleTypeId, address module); error ERC7579UninstalledModule(uint256 moduleTypeId, address module); error ERC7579AlreadyInstalledModule(uint256 moduleTypeId, address module); error ERC7579UnsupportedModuleType(uint256 moduleTypeId); error ERC7579DecodingError(); function execSingle( bytes calldata executionCalldata, ExecType execType ) internal returns (bytes[] memory returnData) { (address target, uint256 value, bytes calldata callData) = decodeSingle(executionCalldata); returnData = new bytes[](1); returnData[0] = _call(0, execType, target, value, callData); } function execBatch( bytes calldata executionCalldata, ExecType execType ) internal returns (bytes[] memory returnData) { Execution[] calldata executionBatch = decodeBatch(executionCalldata); returnData = new bytes[](executionBatch.length); for (uint256 i = 0; i < executionBatch.length; ++i) { returnData[i] = _call( i, execType, executionBatch[i].target, executionBatch[i].value, executionBatch[i].callData ); } } function execDelegateCall( bytes calldata executionCalldata, ExecType execType ) internal returns (bytes[] memory returnData) { (address target, bytes calldata callData) = decodeDelegate(executionCalldata); returnData = new bytes[](1); returnData[0] = _delegatecall(0, execType, target, callData); } function encodeMode( CallType callType, ExecType execType, ModeSelector selector, ModePayload payload ) internal pure returns (Mode mode) { return Mode.wrap( CallType .unwrap(callType) .pack_1_1(ExecType.unwrap(execType)) .pack_2_4(bytes4(0)) .pack_6_4(ModeSelector.unwrap(selector)) .pack_10_22(ModePayload.unwrap(payload)) ); } function decodeMode( Mode mode ) internal pure returns (CallType callType, ExecType execType, ModeSelector selector, ModePayload payload) { return ( CallType.wrap(Packing.extract_32_1(Mode.unwrap(mode), 0x00)), ExecType.wrap(Packing.extract_32_1(Mode.unwrap(mode), 0x01)), ModeSelector.wrap(Packing.extract_32_4(Mode.unwrap(mode), 0x06)), ModePayload.wrap(Packing.extract_32_22(Mode.unwrap(mode), 0x0a)) ); } function encodeSingle( address target, uint256 value, bytes calldata callData ) internal pure returns (bytes memory executionCalldata) { return abi.encodePacked(target, value, callData); } function decodeSingle( bytes calldata executionCalldata ) internal pure returns (address target, uint256 value, bytes calldata callData) { target = address(bytes20(executionCalldata[0x00:0x14])); value = uint256(bytes32(executionCalldata[0x14:0x34])); callData = executionCalldata[0x34:]; } function encodeDelegate( address target, bytes calldata callData ) internal pure returns (bytes memory executionCalldata) { return abi.encodePacked(target, callData); } function decodeDelegate( bytes calldata executionCalldata ) internal pure returns (address target, bytes calldata callData) { target = address(bytes20(executionCalldata[0:0x14])); callData = executionCalldata[0x14:]; } function encodeBatch(Execution[] memory executionBatch) internal pure returns (bytes memory executionCalldata) { return abi.encode(executionBatch); } function decodeBatch(bytes calldata executionCalldata) internal pure returns (Execution[] calldata executionBatch) { unchecked { uint256 bufferLength = executionCalldata.length; if (bufferLength < 0x20) revert ERC7579DecodingError(); uint256 arrayLengthOffset = uint256(bytes32(executionCalldata[0x00:0x20])); if (arrayLengthOffset > bufferLength - 0x20) revert ERC7579DecodingError(); uint256 arrayLength = uint256(bytes32(executionCalldata[arrayLengthOffset:arrayLengthOffset + 0x20])); if (arrayLength > type(uint64).max || bufferLength - arrayLengthOffset - 0x20 < arrayLength * 0x20) revert ERC7579DecodingError(); assembly (\"memory-safe\") { executionBatch.offset := add(add(executionCalldata.offset, arrayLengthOffset), 0x20) executionBatch.length := arrayLength } } } function _call( uint256 index, ExecType execType, address target, uint256 value, bytes calldata data ) private returns (bytes memory) { (bool success, bytes memory returndata) = (target == address(0) ? address(this) : target).call{value: value}( data ); return _validateExecutionMode(index, execType, success, returndata); } function _delegatecall( uint256 index, ExecType execType, address target, bytes calldata data ) private returns (bytes memory) { (bool success, bytes memory returndata) = (target == address(0) ? address(this) : target).delegatecall(data); return _validateExecutionMode(index, execType, success, returndata); } function _validateExecutionMode( uint256 index, ExecType execType, bool success, bytes memory returndata ) private returns (bytes memory) { if (execType == ERC7579Utils.EXECTYPE_DEFAULT) { Address.verifyCallResult(success, returndata); } else if (execType == ERC7579Utils.EXECTYPE_TRY) { if (!success) emit ERC7579TryExecuteFail(index, returndata); } else { revert ERC7579UnsupportedExecType(execType); } return returndata; } } using {eqCallType as ==} for CallType global; using {eqExecType as ==} for ExecType global; using {eqModeSelector as ==} for ModeSelector global; using {eqModePayload as ==} for ModePayload global; function eqCallType(CallType a, CallType b) pure returns (bool) { return CallType.unwrap(a) == CallType.unwrap(b); } function eqExecType(ExecType a, ExecType b) pure returns (bool) { return ExecType.unwrap(a) == ExecType.unwrap(b); } function eqModeSelector(ModeSelector a, ModeSelector b) pure returns (bool) { return ModeSelector.unwrap(a) == ModeSelector.unwrap(b); } function eqModePayload(ModePayload a, ModePayload b) pure returns (bool) { return ModePayload.unwrap(a) == ModePayload.unwrap(b); } ", " pragma solidity ^0.8.20; import {Ownable} from \"./Ownable.sol\"; abstract contract Ownable2Step is Ownable { address private _pendingOwner; event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner); function pendingOwner() public view virtual returns (address) { return _pendingOwner; } function transferOwnership(address newOwner) public virtual override onlyOwner { _pendingOwner = newOwner; emit OwnershipTransferStarted(owner(), newOwner); } function _transferOwnership(address newOwner) internal virtual override { delete _pendingOwner; super._transferOwnership(newOwner); } function acceptOwnership() public virtual { address sender = _msgSender(); if (pendingOwner() != sender) { revert OwnableUnauthorizedAccount(sender); } _transferOwnership(sender); } } ", " pragma solidity ^0.8.24; import {Checkpoints} from \"../../utils/structs/Checkpoints.sol\"; import {Votes} from \"./Votes.sol\"; import {SafeCast} from \"../../utils/math/SafeCast.sol\"; abstract contract VotesExtended is Votes { using Checkpoints for Checkpoints.Trace160; using Checkpoints for Checkpoints.Trace208; mapping(address delegator => Checkpoints.Trace160) private _userDelegationCheckpoints; mapping(address account => Checkpoints.Trace208) private _userVotingUnitsCheckpoints; function getPastDelegate(address account, uint256 timepoint) public view virtual returns (address) { return address(_userDelegationCheckpoints[account].upperLookupRecent(_validateTimepoint(timepoint))); } function getPastBalanceOf(address account, uint256 timepoint) public view virtual returns (uint256) { return _userVotingUnitsCheckpoints[account].upperLookupRecent(_validateTimepoint(timepoint)); } function _delegate(address account, address delegatee) internal virtual override { super._delegate(account, delegatee); _userDelegationCheckpoints[account].push(clock(), uint160(delegatee)); } function _transferVotingUnits(address from, address to, uint256 amount) internal virtual override { super._transferVotingUnits(from, to, amount); if (from != to) { if (from != address(0)) { _userVotingUnitsCheckpoints[from].push(clock(), SafeCast.toUint208(_getVotingUnits(from))); } if (to != address(0)) { _userVotingUnitsCheckpoints[to].push(clock(), SafeCast.toUint208(_getVotingUnits(to))); } } } } ", " pragma solidity ^0.8.24; import {IGovernor, Governor} from \"../Governor.sol\"; abstract contract GovernorSequentialProposalId is Governor { uint256 private _latestProposalId; mapping(uint256 proposalHash => uint256 proposalId) private _proposalIds; error GovernorAlreadyInitializedLatestProposalId(); function getProposalId( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash ) public view virtual override returns (uint256) { uint256 proposalHash = hashProposal(targets, values, calldatas, descriptionHash); uint256 storedProposalId = _proposalIds[proposalHash]; if (storedProposalId == 0) { revert GovernorNonexistentProposal(0); } return storedProposalId; } function latestProposalId() public view virtual returns (uint256) { return _latestProposalId; } function _propose( address[] memory targets, uint256[] memory values, bytes[] memory calldatas, string memory description, address proposer ) internal virtual override returns (uint256) { uint256 proposalHash = hashProposal(targets, values, calldatas, keccak256(bytes(description))); uint256 storedProposalId = _proposalIds[proposalHash]; if (storedProposalId == 0) { _proposalIds[proposalHash] = ++_latestProposalId; } return super._propose(targets, values, calldatas, description, proposer); } function _initializeLatestProposalId(uint256 newLatestProposalId) internal virtual { if (_latestProposalId != 0) { revert GovernorAlreadyInitializedLatestProposalId(); } _latestProposalId = newLatestProposalId; } } ", " pragma solidity >=0.5.0; import {IERC3156FlashBorrower} from \"./IERC3156FlashBorrower.sol\"; interface IERC3156FlashLender { function maxFlashLoan(address token) external view returns (uint256); function flashFee(address token, uint256 amount) external view returns (uint256); function flashLoan( IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data ) external returns (bool); } ", " pragma solidity ^0.8.20; import {AccessControl} from \"../access/AccessControl.sol\"; import {ERC721Holder} from \"../token/ERC721/utils/ERC721Holder.sol\"; import {ERC1155Holder} from \"../token/ERC1155/utils/ERC1155Holder.sol\"; import {Address} from \"../utils/Address.sol\"; import {IERC165} from \"../utils/introspection/ERC165.sol\"; contract TimelockController is AccessControl, ERC721Holder, ERC1155Holder { bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\"); bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\"); bytes32 public constant CANCELLER_ROLE = keccak256(\"CANCELLER_ROLE\"); uint256 internal constant DONE_TIMESTAMP = uint256(1); mapping(bytes32 id => uint256) private _timestamps; uint256 private _minDelay; enum OperationState { Unset, Waiting, Ready, Done } error TimelockInvalidOperationLength(uint256 targets, uint256 payloads, uint256 values); error TimelockInsufficientDelay(uint256 delay, uint256 minDelay); error TimelockUnexpectedOperationState(bytes32 operationId, bytes32 expectedStates); error TimelockUnexecutedPredecessor(bytes32 predecessorId); error TimelockUnauthorizedCaller(address caller); event CallScheduled( bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data, bytes32 predecessor, uint256 delay ); event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data); event CallSalt(bytes32 indexed id, bytes32 salt); event Cancelled(bytes32 indexed id); event MinDelayChange(uint256 oldDuration, uint256 newDuration); constructor(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) { _grantRole(DEFAULT_ADMIN_ROLE, address(this)); if (admin != address(0)) { _grantRole(DEFAULT_ADMIN_ROLE, admin); } for (uint256 i = 0; i < proposers.length; ++i) { _grantRole(PROPOSER_ROLE, proposers[i]); _grantRole(CANCELLER_ROLE, proposers[i]); } for (uint256 i = 0; i < executors.length; ++i) { _grantRole(EXECUTOR_ROLE, executors[i]); } _minDelay = minDelay; emit MinDelayChange(0, minDelay); } modifier onlyRoleOrOpenRole(bytes32 role) { if (!hasRole(role, address(0))) { _checkRole(role, _msgSender()); } _; } receive() external payable virtual {} function supportsInterface( bytes4 interfaceId ) public view virtual override(AccessControl, ERC1155Holder) returns (bool) { return super.supportsInterface(interfaceId); } function isOperation(bytes32 id) public view returns (bool) { return getOperationState(id) != OperationState.Unset; } function isOperationPending(bytes32 id) public view returns (bool) { OperationState state = getOperationState(id); return state == OperationState.Waiting || state == OperationState.Ready; } function isOperationReady(bytes32 id) public view returns (bool) { return getOperationState(id) == OperationState.Ready; } function isOperationDone(bytes32 id) public view returns (bool) { return getOperationState(id) == OperationState.Done; } function getTimestamp(bytes32 id) public view virtual returns (uint256) { return _timestamps[id]; } function getOperationState(bytes32 id) public view virtual returns (OperationState) { uint256 timestamp = getTimestamp(id); if (timestamp == 0) { return OperationState.Unset; } else if (timestamp == DONE_TIMESTAMP) { return OperationState.Done; } else if (timestamp > block.timestamp) { return OperationState.Waiting; } else { return OperationState.Ready; } } function getMinDelay() public view virtual returns (uint256) { return _minDelay; } function hashOperation( address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt ) public pure virtual returns (bytes32) { return keccak256(abi.encode(target, value, data, predecessor, salt)); } function hashOperationBatch( address[] calldata targets, uint256[] calldata values, bytes[] calldata payloads, bytes32 predecessor, bytes32 salt ) public pure virtual returns (bytes32) { return keccak256(abi.encode(targets, values, payloads, predecessor, salt)); } function schedule( address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt, uint256 delay ) public virtual onlyRole(PROPOSER_ROLE) { bytes32 id = hashOperation(target, value, data, predecessor, salt); _schedule(id, delay); emit CallScheduled(id, 0, target, value, data, predecessor, delay); if (salt != bytes32(0)) { emit CallSalt(id, salt); } } function scheduleBatch( address[] calldata targets, uint256[] calldata values, bytes[] calldata payloads, bytes32 predecessor, bytes32 salt, uint256 delay ) public virtual onlyRole(PROPOSER_ROLE) { if (targets.length != values.length || targets.length != payloads.length) { revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length); } bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt); _schedule(id, delay); for (uint256 i = 0; i < targets.length; ++i) { emit CallScheduled(id, i, targets[i], values[i], payloads[i], predecessor, delay); } if (salt != bytes32(0)) { emit CallSalt(id, salt); } } function _schedule(bytes32 id, uint256 delay) private { if (isOperation(id)) { revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Unset)); } uint256 minDelay = getMinDelay(); if (delay < minDelay) { revert TimelockInsufficientDelay(delay, minDelay); } _timestamps[id] = block.timestamp + delay; } function cancel(bytes32 id) public virtual onlyRole(CANCELLER_ROLE) { if (!isOperationPending(id)) { revert TimelockUnexpectedOperationState( id, _encodeStateBitmap(OperationState.Waiting) | _encodeStateBitmap(OperationState.Ready) ); } delete _timestamps[id]; emit Cancelled(id); } function execute( address target, uint256 value, bytes calldata payload, bytes32 predecessor, bytes32 salt ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) { bytes32 id = hashOperation(target, value, payload, predecessor, salt); _beforeCall(id, predecessor); _execute(target, value, payload); emit CallExecuted(id, 0, target, value, payload); _afterCall(id); } function executeBatch( address[] calldata targets, uint256[] calldata values, bytes[] calldata payloads, bytes32 predecessor, bytes32 salt ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) { if (targets.length != values.length || targets.length != payloads.length) { revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length); } bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt); _beforeCall(id, predecessor); for (uint256 i = 0; i < targets.length; ++i) { address target = targets[i]; uint256 value = values[i]; bytes calldata payload = payloads[i]; _execute(target, value, payload); emit CallExecuted(id, i, target, value, payload); } _afterCall(id); } function _execute(address target, uint256 value, bytes calldata data) internal virtual { (bool success, bytes memory returndata) = target.call{value: value}(data); Address.verifyCallResult(success, returndata); } function _beforeCall(bytes32 id, bytes32 predecessor) private view { if (!isOperationReady(id)) { revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Ready)); } if (predecessor != bytes32(0) && !isOperationDone(predecessor)) { revert TimelockUnexecutedPredecessor(predecessor); } } function _afterCall(bytes32 id) private { if (!isOperationReady(id)) { revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Ready)); } _timestamps[id] = DONE_TIMESTAMP; } function updateDelay(uint256 newDelay) public virtual { address sender = _msgSender(); if (sender != address(this)) { revert TimelockUnauthorizedCaller(sender); } emit MinDelayChange(_minDelay, newDelay); _minDelay = newDelay; } function _encodeStateBitmap(OperationState operationState) internal pure returns (bytes32) { return bytes32(1 << uint8(operationState)); } } ", " pragma solidity ^0.8.24; import {IGovernor, Governor} from \"../Governor.sol\"; abstract contract GovernorSettings is Governor { uint256 private _proposalThreshold; uint48 private _votingDelay; uint32 private _votingPeriod; event VotingDelaySet(uint256 oldVotingDelay, uint256 newVotingDelay); event VotingPeriodSet(uint256 oldVotingPeriod, uint256 newVotingPeriod); event ProposalThresholdSet(uint256 oldProposalThreshold, uint256 newProposalThreshold); constructor(uint48 initialVotingDelay, uint32 initialVotingPeriod, uint256 initialProposalThreshold) { _setVotingDelay(initialVotingDelay); _setVotingPeriod(initialVotingPeriod); _setProposalThreshold(initialProposalThreshold); } function votingDelay() public view virtual override returns (uint256) { return _votingDelay; } function votingPeriod() public view virtual override returns (uint256) { return _votingPeriod; } function proposalThreshold() public view virtual override returns (uint256) { return _proposalThreshold; } function setVotingDelay(uint48 newVotingDelay) public virtual onlyGovernance { _setVotingDelay(newVotingDelay); } function setVotingPeriod(uint32 newVotingPeriod) public virtual onlyGovernance { _setVotingPeriod(newVotingPeriod); } function setProposalThreshold(uint256 newProposalThreshold) public virtual onlyGovernance { _setProposalThreshold(newProposalThreshold); } function _setVotingDelay(uint48 newVotingDelay) internal virtual { emit VotingDelaySet(_votingDelay, newVotingDelay); _votingDelay = newVotingDelay; } function _setVotingPeriod(uint32 newVotingPeriod) internal virtual { if (newVotingPeriod == 0) { revert GovernorInvalidVotingPeriod(0); } emit VotingPeriodSet(_votingPeriod, newVotingPeriod); _votingPeriod = newVotingPeriod; } function _setProposalThreshold(uint256 newProposalThreshold) internal virtual { emit ProposalThresholdSet(_proposalThreshold, newProposalThreshold); _proposalThreshold = newProposalThreshold; } } ", " pragma solidity >=0.5.0; interface IERC777 { event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData); event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData); event AuthorizedOperator(address indexed operator, address indexed tokenHolder); event RevokedOperator(address indexed operator, address indexed tokenHolder); function name() external view returns (string memory); function symbol() external view returns (string memory); function granularity() external view returns (uint256); function totalSupply() external view returns (uint256); function balanceOf(address owner) external view returns (uint256); function send(address recipient, uint256 amount, bytes calldata data) external; function burn(uint256 amount, bytes calldata data) external; function isOperatorFor(address operator, address tokenHolder) external view returns (bool); function authorizeOperator(address operator) external; function revokeOperator(address operator) external; function defaultOperators() external view returns (address[] memory); function operatorSend( address sender, address recipient, uint256 amount, bytes calldata data, bytes calldata operatorData ) external; function operatorBurn(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) external; event Sent( address indexed operator, address indexed from, address indexed to, uint256 amount, bytes data, bytes operatorData ); } ", " pragma solidity >=0.4.16; import {IERC165} from \"../utils/introspection/IERC165.sol\"; ", " pragma solidity ^0.8.20; import {IAccessControl} from \"./IAccessControl.sol\"; import {Context} from \"../utils/Context.sol\"; import {IERC165, ERC165} from \"../utils/introspection/ERC165.sol\"; abstract contract AccessControl is Context, IAccessControl, ERC165 { struct RoleData { mapping(address account => bool) hasRole; bytes32 adminRole; } mapping(bytes32 role => RoleData) private _roles; bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00; modifier onlyRole(bytes32 role) { _checkRole(role); _; } function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId); } function hasRole(bytes32 role, address account) public view virtual returns (bool) { return _roles[role].hasRole[account]; } function _checkRole(bytes32 role) internal view virtual { _checkRole(role, _msgSender()); } function _checkRole(bytes32 role, address account) internal view virtual { if (!hasRole(role, account)) { revert AccessControlUnauthorizedAccount(account, role); } } function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) { return _roles[role].adminRole; } function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) { _grantRole(role, account); } function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) { _revokeRole(role, account); } function renounceRole(bytes32 role, address callerConfirmation) public virtual { if (callerConfirmation != _msgSender()) { revert AccessControlBadConfirmation(); } _revokeRole(role, callerConfirmation); } function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual { bytes32 previousAdminRole = getRoleAdmin(role); _roles[role].adminRole = adminRole; emit RoleAdminChanged(role, previousAdminRole, adminRole); } function _grantRole(bytes32 role, address account) internal virtual returns (bool) { if (!hasRole(role, account)) { _roles[role].hasRole[account] = true; emit RoleGranted(role, account, _msgSender()); return true; } else { return false; } } function _revokeRole(bytes32 role, address account) internal virtual returns (bool) { if (hasRole(role, account)) { _roles[role].hasRole[account] = false; emit RoleRevoked(role, account, _msgSender()); return true; } else { return false; } } } ", " pragma solidity >=0.5.0; interface IERC1271 { function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4 magicValue); } ", " pragma solidity ^0.8.24; import {GovernorVotes} from \"./GovernorVotes.sol\"; import {Math} from \"../../utils/math/Math.sol\"; import {SafeCast} from \"../../utils/math/SafeCast.sol\"; import {Checkpoints} from \"../../utils/structs/Checkpoints.sol\"; abstract contract GovernorVotesQuorumFraction is GovernorVotes { using Checkpoints for Checkpoints.Trace208; Checkpoints.Trace208 private _quorumNumeratorHistory; event QuorumNumeratorUpdated(uint256 oldQuorumNumerator, uint256 newQuorumNumerator); error GovernorInvalidQuorumFraction(uint256 quorumNumerator, uint256 quorumDenominator); constructor(uint256 quorumNumeratorValue) { _updateQuorumNumerator(quorumNumeratorValue); } function quorumNumerator() public view virtual returns (uint256) { return _quorumNumeratorHistory.latest(); } function quorumNumerator(uint256 timepoint) public view virtual returns (uint256) { return _optimisticUpperLookupRecent(_quorumNumeratorHistory, timepoint); } function quorumDenominator() public view virtual returns (uint256) { return 100; } function quorum(uint256 timepoint) public view virtual override returns (uint256) { return Math.mulDiv(token().getPastTotalSupply(timepoint), quorumNumerator(timepoint), quorumDenominator()); } function updateQuorumNumerator(uint256 newQuorumNumerator) public virtual onlyGovernance { _updateQuorumNumerator(newQuorumNumerator); } function _updateQuorumNumerator(uint256 newQuorumNumerator) internal virtual { uint256 denominator = quorumDenominator(); if (newQuorumNumerator > denominator) { revert GovernorInvalidQuorumFraction(newQuorumNumerator, denominator); } uint256 oldQuorumNumerator = quorumNumerator(); _quorumNumeratorHistory.push(clock(), SafeCast.toUint208(newQuorumNumerator)); emit QuorumNumeratorUpdated(oldQuorumNumerator, newQuorumNumerator); } function _optimisticUpperLookupRecent( Checkpoints.Trace208 storage ckpts, uint256 timepoint ) internal view returns (uint256) { (, uint48 key, uint208 value) = ckpts.latestCheckpoint(); return key <= timepoint ? value : ckpts.upperLookupRecent(SafeCast.toUint48(timepoint)); } } "], "y": ["vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "vulnerable", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure", "secure"]}